{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 11, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/utils.js"],"sourcesContent":["//\n// Utilities\n//\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nexport function inRange(a, min, max) {\n  return min <= a && a <= max\n}\n\nexport const floor = Math.floor\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nexport function stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string)\n\n  // 2. Let n be the length of S.\n  var n = s.length\n\n  // 3. Initialize i to 0.\n  var i = 0\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = []\n\n  // 5. While i < n:\n  while (i < n) {\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i)\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c)\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD)\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD)\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = s.charCodeAt(i + 1)\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b)\n\n          // 4. Set i to i+1.\n          i += 1\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD)\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1\n  }\n\n  // 6. Return U.\n  return u\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nexport function codePointsToString(code_points) {\n  var s = ''\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i]\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp)\n    } else {\n      cp -= 0x10000\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n        (cp & 0x3FF) + 0xDC00)\n    }\n  }\n  return s\n}\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return The code point to insert on a decoding error.\n */\nexport function decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error')\n  return opt_code_point || 0xFFFD\n}\n\n/**\n * @param {number} code_point The code point that could not be encoded.\n * @return {number} Always throws, no value is actually returned.\n */\nexport function encoderError(code_point) {\n  throw TypeError('The code point ' + code_point + ' could not be encoded.')\n}\n\n/**\n * @param {number} code_unit\n * @param {boolean} utf16be\n */\nexport function convertCodeUnitToBytes(code_unit, utf16be) {\n  // 1. Let byte1 be code unit >> 8.\n  const byte1 = code_unit >> 8\n\n  // 2. Let byte2 be code unit & 0x00FF.\n  const byte2 = code_unit & 0x00FF\n\n  // 3. Then return the bytes in order:\n  // utf-16be flag is set: byte1, then byte2.\n  if (utf16be)\n    return [byte1, byte2]\n  // utf-16be flag is unset: byte2, then byte1.\n  return [byte2, byte1]\n}\n\n\n//\n// 4. Terminology\n//\n\n/**\n * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n * @param {number} a The number to test.\n * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n */\nexport function isASCIIByte(a) {\n  return 0x00 <= a && a <= 0x7F\n}\n\n/**\n * An ASCII code point is a code point in the range U+0000 to\n * U+007F, inclusive.\n */\nexport const isASCIICodePoint = isASCIIByte\n\n/**\n * End-of-stream is a special token that signifies no more tokens are in the stream.\n */\nexport const end_of_stream = -1\n\nexport const finished = -1"],"names":[],"mappings":"AAAA,EAAE;AACF,YAAY;AACZ,EAAE;AACF;;;;;CAKC;;;;;;;;;;;;;AACM,SAAS,QAAQ,CAAC,EAAE,GAAG,EAAE,GAAG;IACjC,OAAO,OAAO,KAAK,KAAK;AAC1B;AAEO,MAAM,QAAQ,KAAK,KAAK;AAMxB,SAAS,mBAAmB,MAAM;IACvC,sDAAsD;IAEtD,mCAAmC;IACnC,IAAI,IAAI,OAAO;IAEf,+BAA+B;IAC/B,IAAI,IAAI,EAAE,MAAM;IAEhB,wBAAwB;IACxB,IAAI,IAAI;IAER,iEAAiE;IACjE,IAAI,IAAI,EAAE;IAEV,kBAAkB;IAClB,MAAO,IAAI,EAAG;QACZ,6CAA6C;QAC7C,IAAI,IAAI,EAAE,UAAU,CAAC;QAErB,kCAAkC;QAElC,2BAA2B;QAC3B,IAAI,IAAI,UAAU,IAAI,QAAQ;YAC5B,uDAAuD;YACvD,EAAE,IAAI,CAAC;QACT,OAGK,IAAI,UAAU,KAAK,KAAK,QAAQ;YACnC,8CAA8C;YAC9C,EAAE,IAAI,CAAC;QACT,OAGK,IAAI,UAAU,KAAK,KAAK,QAAQ;YACnC,uDAAuD;YACvD,aAAa;YACb,IAAI,MAAM,IAAI,GAAG;gBACf,EAAE,IAAI,CAAC;YACT,OAEK;gBACH,+CAA+C;gBAC/C,IAAI,IAAI,EAAE,UAAU,CAAC,IAAI;gBAEzB,mCAAmC;gBACnC,IAAI,UAAU,KAAK,KAAK,QAAQ;oBAC9B,yBAAyB;oBACzB,IAAI,IAAI,IAAI;oBAEZ,yBAAyB;oBACzB,IAAI,IAAI,IAAI;oBAEZ,uDAAuD;oBACvD,iBAAiB;oBACjB,EAAE,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI;oBAE7B,mBAAmB;oBACnB,KAAK;gBACP,OAIM;oBACJ,EAAE,IAAI,CAAC;gBACT;YACF;QACF;QAEA,mBAAmB;QACnB,KAAK;IACP;IAEA,eAAe;IACf,OAAO;AACT;AAMO,SAAS,mBAAmB,WAAW;IAC5C,IAAI,IAAI;IACR,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,MAAM,EAAE,EAAE,EAAG;QAC3C,IAAI,KAAK,WAAW,CAAC,EAAE;QACvB,IAAI,MAAM,QAAQ;YAChB,KAAK,OAAO,YAAY,CAAC;QAC3B,OAAO;YACL,MAAM;YACN,KAAK,OAAO,YAAY,CAAC,CAAC,MAAM,EAAE,IAAI,QACpC,CAAC,KAAK,KAAK,IAAI;QACnB;IACF;IACA,OAAO;AACT;AAOO,SAAS,aAAa,KAAK,EAAE,cAAc;IAChD,IAAI,OACF,MAAM,UAAU;IAClB,OAAO,kBAAkB;AAC3B;AAMO,SAAS,aAAa,UAAU;IACrC,MAAM,UAAU,oBAAoB,aAAa;AACnD;AAMO,SAAS,uBAAuB,SAAS,EAAE,OAAO;IACvD,kCAAkC;IAClC,MAAM,QAAQ,aAAa;IAE3B,sCAAsC;IACtC,MAAM,QAAQ,YAAY;IAE1B,qCAAqC;IACrC,2CAA2C;IAC3C,IAAI,SACF,OAAO;QAAC;QAAO;KAAM;IACvB,6CAA6C;IAC7C,OAAO;QAAC;QAAO;KAAM;AACvB;AAYO,SAAS,YAAY,CAAC;IAC3B,OAAO,QAAQ,KAAK,KAAK;AAC3B;AAMO,MAAM,mBAAmB;AAKzB,MAAM,gBAAgB,CAAC;AAEvB,MAAM,WAAW,CAAC"}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/indexes.js"],"sourcesContent":["import { inRange } from './utils'\nimport Indexes from './encoding-indexes'\n\n//\n// 6. Indexes\n//\n\n/**\n * @param {number} pointer The |pointer| to search for.\n * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in |index|.\n */\nexport function indexCodePointFor(pointer, i) {\n  if (!i) return null\n  return i[pointer] || null\n}\n\n/**\n * @param {number} code_point The |code point| to search for.\n * @param {!Array.<?number>} i The |index| to search within.\n * @return {?number} The first pointer corresponding to |code point| in\n *     |index|, or null if |code point| is not in |index|.\n */\nexport function indexPointerFor(code_point, i) {\n  var pointer = i.indexOf(code_point)\n  return pointer === -1 ? null : pointer\n}\n\n/**\n * @param {string} name Name of the index.\n */\nexport default function index(name) {\n  return Indexes[name]\n}\n\n/**\n * @param {number} pointer The |pointer| to search for in the gb18030 index.\n * @return The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the gb18030 index.\n */\nexport function indexGB18030RangesCodePointFor(pointer) {\n  // 1. If pointer is greater than 39419 and less than 189000, or\n  // pointer is greater than 1237575, return null.\n  if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))\n    return null\n\n  // 2. If pointer is 7457, return code point U+E7C7.\n  if (pointer === 7457) return 0xE7C7\n\n  // 3. Let offset be the last pointer in index gb18030 ranges that\n  // is equal to or less than pointer and let code point offset be\n  // its corresponding code point.\n  var offset = 0\n  var code_point_offset = 0\n  var idx = index('gb18030-ranges')\n  var i\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i]\n    if (entry[0] <= pointer) {\n      offset = entry[0]\n      code_point_offset = entry[1]\n    } else {\n      break\n    }\n  }\n\n  // 4. Return a code point whose value is code point offset +\n  // pointer − offset.\n  return code_point_offset + pointer - offset\n}\n\n/**\n * @param {number} code_point The |code point| to locate in the gb18030 index.\n * @return {number} The first pointer corresponding to |code point| in the\n *     gb18030 index.\n */\nexport function indexGB18030RangesPointerFor(code_point) {\n  // 1. If code point is U+E7C7, return pointer 7457.\n  if (code_point === 0xE7C7) return 7457\n\n  // 2. Let offset be the last code point in index gb18030 ranges\n  // that is equal to or less than code point and let pointer offset\n  // be its corresponding pointer.\n  var offset = 0\n  var pointer_offset = 0\n  var idx = index('gb18030-ranges')\n  var i\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i]\n    if (entry[1] <= code_point) {\n      offset = entry[1]\n      pointer_offset = entry[0]\n    } else {\n      break\n    }\n  }\n\n  // 3. Return a pointer whose value is pointer offset + code point\n  // − offset.\n  return pointer_offset + code_point - offset\n}\n\n/**\n * @param {number} code_point The |code_point| to search for in the Shift_JIS\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the Shift_JIS index.\n */\nexport function indexShiftJISPointerFor(code_point) {\n  // 1. Let index be index jis0208 excluding all entries whose\n  // pointer is in the range 8272 to 8835, inclusive.\n  shift_jis_index = shift_jis_index ||\n    index('jis0208').map((cp, pointer) => {\n      return inRange(pointer, 8272, 8835) ? null : cp\n    })\n  const index_ = shift_jis_index\n\n  // 2. Return the index pointer for code point in index.\n  return index_.indexOf(code_point)\n}\nvar shift_jis_index\n\n/**\n * @param {number} code_point The |code_point| to search for in the big5\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the big5 index.\n */\nexport function indexBig5PointerFor(code_point) {\n  // 1. Let index be index Big5 excluding all entries whose pointer\n  big5_index_no_hkscs = big5_index_no_hkscs ||\n    index('big5').map((cp, pointer) => {\n      return (pointer < (0xA1 - 0x81) * 157) ? null : cp\n    })\n  var index_ = big5_index_no_hkscs\n\n  // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n  // U+5345, return the last pointer corresponding to code point in\n  // index.\n  if (code_point === 0x2550 || code_point === 0x255E ||\n      code_point === 0x2561 || code_point === 0x256A ||\n      code_point === 0x5341 || code_point === 0x5345) {\n    return index_.lastIndexOf(code_point)\n  }\n\n  // 3. Return the index pointer for code point in index.\n  return indexPointerFor(code_point, index_)\n}\n\nvar big5_index_no_hkscs"],"names":[],"mappings":";;;;;;;;;;;;;;AAaO,SAAS,kBAAkB,OAAO,EAAE,CAAC;IAC1C,IAAI,CAAC,GAAG,OAAO;IACf,OAAO,CAAC,CAAC,QAAQ,IAAI;AACvB;AAQO,SAAS,gBAAgB,UAAU,EAAE,CAAC;IAC3C,IAAI,UAAU,EAAE,OAAO,CAAC;IACxB,OAAO,YAAY,CAAC,IAAI,OAAO;AACjC;AAKe,SAAS,MAAM,IAAI;IAChC,OAAO,yKAAO,CAAC,KAAK;AACtB;AAOO,SAAS,+BAA+B,OAAO;IACpD,+DAA+D;IAC/D,gDAAgD;IAChD,IAAI,AAAC,UAAU,SAAS,UAAU,UAAY,UAAU,SACtD,OAAO;IAET,mDAAmD;IACnD,IAAI,YAAY,MAAM,OAAO;IAE7B,iEAAiE;IACjE,gEAAgE;IAChE,gCAAgC;IAChC,IAAI,SAAS;IACb,IAAI,oBAAoB;IACxB,IAAI,MAAM,MAAM;IAChB,IAAI;IACJ,IAAK,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,EAAE,EAAG;QAC/B,4BAA4B,GAC5B,IAAI,QAAQ,GAAG,CAAC,EAAE;QAClB,IAAI,KAAK,CAAC,EAAE,IAAI,SAAS;YACvB,SAAS,KAAK,CAAC,EAAE;YACjB,oBAAoB,KAAK,CAAC,EAAE;QAC9B,OAAO;YACL;QACF;IACF;IAEA,4DAA4D;IAC5D,oBAAoB;IACpB,OAAO,oBAAoB,UAAU;AACvC;AAOO,SAAS,6BAA6B,UAAU;IACrD,mDAAmD;IACnD,IAAI,eAAe,QAAQ,OAAO;IAElC,+DAA+D;IAC/D,kEAAkE;IAClE,gCAAgC;IAChC,IAAI,SAAS;IACb,IAAI,iBAAiB;IACrB,IAAI,MAAM,MAAM;IAChB,IAAI;IACJ,IAAK,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,EAAE,EAAG;QAC/B,4BAA4B,GAC5B,IAAI,QAAQ,GAAG,CAAC,EAAE;QAClB,IAAI,KAAK,CAAC,EAAE,IAAI,YAAY;YAC1B,SAAS,KAAK,CAAC,EAAE;YACjB,iBAAiB,KAAK,CAAC,EAAE;QAC3B,OAAO;YACL;QACF;IACF;IAEA,iEAAiE;IACjE,YAAY;IACZ,OAAO,iBAAiB,aAAa;AACvC;AAQO,SAAS,wBAAwB,UAAU;IAChD,4DAA4D;IAC5D,mDAAmD;IACnD,kBAAkB,mBAChB,MAAM,WAAW,GAAG,CAAC,CAAC,IAAI;QACxB,OAAO,4JAAQ,SAAS,MAAM,QAAQ,OAAO;IAC/C;IACF,MAAM,SAAS;IAEf,uDAAuD;IACvD,OAAO,OAAO,OAAO,CAAC;AACxB;AACA,IAAI;AAQG,SAAS,oBAAoB,UAAU;IAC5C,iEAAiE;IACjE,sBAAsB,uBACpB,MAAM,QAAQ,GAAG,CAAC,CAAC,IAAI;QACrB,OAAO,AAAC,UAAU,CAAC,OAAO,IAAI,IAAI,MAAO,OAAO;IAClD;IACF,IAAI,SAAS;IAEb,iEAAiE;IACjE,iEAAiE;IACjE,SAAS;IACT,IAAI,eAAe,UAAU,eAAe,UACxC,eAAe,UAAU,eAAe,UACxC,eAAe,UAAU,eAAe,QAAQ;QAClD,OAAO,OAAO,WAAW,CAAC;IAC5B;IAEA,uDAAuD;IACvD,OAAO,gBAAgB,YAAY;AACrC;AAEA,IAAI"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 247, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/single-byte.js"],"sourcesContent":["import { end_of_stream, finished, isASCIIByte, decoderError, encoderError, isASCIICodePoint } from '../utils'\nimport { indexPointerFor } from '../indexes'\n\n//\n// 10. Legacy single-byte encodings\n//\n\n// 10.1 single-byte decoder\n/**\n * @implements {Decoder}\n */\nexport class SingleByteDecoder {\n  /**\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  constructor(index, options) {\n    const { fatal } = options\n    this.fatal = fatal\n    this.index = index\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 3. Let code point be the index code point for byte − 0x80 in\n    // index single-byte.\n    var code_point = this.index[bite - 0x80]\n\n    // 4. If code point is null, return error.\n    if (code_point === null)\n      return decoderError(this.fatal)\n\n    // 5. Return a code point whose value is code point.\n    return code_point\n  }\n}\n\n// 10.2 single-byte encoder\n/**\n * @implements {Encoder}\n */\nexport class SingleByteEncoder {\n  /**\n   * @param {!Array.<?number>} index The encoding index.\n   */\n  constructor(index) {\n    this.index = index\n  }\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. Let pointer be the index pointer for code point in index\n    // single-byte.\n    const pointer = indexPointerFor(code_point, this.index)\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null)\n      encoderError(code_point)\n\n    // 5. Return a byte whose value is pointer + 0x80.\n    return pointer + 0x80\n  }\n}"],"names":[],"mappings":";;;;;;;;;AAWO,MAAM;IACX;;;GAGC,GACD,YAAY,KAAK,EAAE,OAAO,CAAE;QAC1B,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;IACf;IACA;;;GAGC,GACD,QAAQ,MAAM,EAAE,IAAI,EAAE;QACtB,gDAAgD;QAC9C,IAAI,4KACF;QAEF,+DAA+D;QAC/D,WAAW;QACX,IAAI,gKAAY,OACd,OAAO;QAET,+DAA+D;QAC/D,qBAAqB;QACrB,IAAI,aAAa,IAAI,CAAC,KAAK,CAAC,OAAO,KAAK;QAExC,0CAA0C;QAC1C,IAAI,eAAe,MACjB,OAAO,iKAAa,IAAI,CAAC,KAAK;QAEhC,oDAAoD;QACpD,OAAO;IACT;AACF;AAMO,MAAM;IACX;;GAEC,GACD,YAAY,KAAK,CAAE;QACjB,IAAI,CAAC,KAAK,GAAG;IACf;IACA;;;;GAIC,GACD,QAAQ,MAAM,EAAE,UAAU,EAAE;QAC1B,sDAAsD;QACtD,IAAI,kLACF;QAEF,+DAA+D;QAC/D,uBAAuB;QACvB,IAAI,qKAAiB,aACnB,OAAO;QAET,8DAA8D;QAC9D,eAAe;QACf,MAAM,UAAU,sKAAgB,YAAY,IAAI,CAAC,KAAK;QAEtD,uDAAuD;QACvD,IAAI,YAAY,MACd,iKAAa;QAEf,kDAAkD;QAClD,OAAO,UAAU;IACnB;AACF"}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 313, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/shift-jis.js"],"sourcesContent":["import { inRange, decoderError, encoderError, floor, isASCIICodePoint, isASCIIByte,\n  end_of_stream, finished } from '../utils'\nimport index, { indexCodePointFor, indexShiftJISPointerFor } from '../indexes'\n\n\n// 13.3 Shift_JIS\n\n// 13.3.1 Shift_JIS decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nexport class ShiftJISDecoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n    this.Shift_JIS_lead = 0x00\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n  // set Shift_JIS lead to 0x00 and return error.\n    if (bite === end_of_stream && this.Shift_JIS_lead !== 0x00) {\n      this.Shift_JIS_lead = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n    // return finished.\n    if (bite === end_of_stream && this.Shift_JIS_lead === 0x00)\n      return finished\n\n    // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n    // let pointer be null, set Shift_JIS lead to 0x00, and then run\n    // these substeps:\n    if (this.Shift_JIS_lead !== 0x00) {\n      var lead = this.Shift_JIS_lead\n      var pointer = null\n      this.Shift_JIS_lead = 0x00\n\n      // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n      // otherwise.\n      var offset = (bite < 0x7F) ? 0x40 : 0x41\n\n      // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n      // 0xC1 otherwise.\n      var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1\n\n      // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n      // 188 + byte − offset.\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\n        pointer = (lead - lead_offset) * 188 + bite - offset\n\n      // 4. If pointer is in the range 8836 to 10715, inclusive,\n      // return a code point whose value is 0xE000 − 8836 + pointer.\n      if (inRange(pointer, 8836, 10715))\n        return 0xE000 - 8836 + pointer\n\n      // 5. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index jis0208 otherwise.\n      var code_point = (pointer === null) ? null :\n        indexCodePointFor(pointer, index('jis0208'))\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite))\n        stream.prepend(bite)\n\n      // 7. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 8. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 4. If byte is an ASCII byte or 0x80, return a code point\n    // whose value is byte.\n    if (isASCIIByte(bite) || bite === 0x80)\n      return bite\n\n    // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n    // code point whose value is 0xFF61 − 0xA1 + byte.\n    if (inRange(bite, 0xA1, 0xDF))\n      return 0xFF61 - 0xA1 + bite\n\n    // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n    // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n    // continue.\n    if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n      this.Shift_JIS_lead = bite\n      return null\n    }\n\n    // 7. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n// 13.3.2 Shift_JIS encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nexport class ShiftJISEncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n  // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point or U+0080, return a\n    // byte whose value is code point.\n    if (isASCIICodePoint(code_point) || code_point === 0x0080)\n      return code_point\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00A5)\n      return 0x5C\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203E)\n      return 0x7E\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return a byte whose value is code point − 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xFF61, 0xFF9F))\n      return code_point - 0xFF61 + 0xA1\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212)\n      code_point = 0xFF0D\n\n    // 7. Let pointer be the index Shift_JIS pointer for code point.\n    var pointer = indexShiftJISPointerFor(code_point)\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null)\n      return encoderError(code_point)\n\n    // 9. Let lead be floor(pointer / 188).\n    var lead = floor(pointer / 188)\n\n    // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n    // 0xC1 otherwise.\n    var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1\n\n    // 11. Let trail be pointer % 188.\n    var trail = pointer % 188\n\n    // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n    // otherwise.\n    var offset = (trail < 0x3F) ? 0x40 : 0x41\n\n    // 13. Return two bytes whose values are lead + lead offset and\n    // trail + offset.\n    return [lead + lead_offset, trail + offset]\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 432, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 437, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/x-user-defined.js"],"sourcesContent":["import { inRange, encoderError, end_of_stream, finished, isASCIIByte, isASCIICodePoint } from '../utils'\n\n// 15.5 x-user-defined\n\n// 15.5.1 x-user-defined decoder\n/**\n * @implements {Decoder}\n */\nexport class XUserDefinedDecoder {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n    return 0xF780 + bite - 0x80\n  }\n}\n\n// 15.5.2 x-user-defined encoder\n/**\n * @implements {Encoder}\n */\nexport class XUserDefinedEncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n  // 1.If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n    // return a byte whose value is code point − 0xF780 + 0x80.\n    if (inRange(code_point, 0xF780, 0xF7FF))\n      return code_point - 0xF780 + 0x80\n\n    // 4. Return error with code point.\n    return encoderError(code_point)\n  }\n}"],"names":[],"mappings":";;;;;;;AAQO,MAAM;IACX;;;GAGC,GACD,QAAQ,MAAM,EAAE,IAAI,EAAE;QACtB,gDAAgD;QAC9C,IAAI,4KACF;QAEF,+DAA+D;QAC/D,WAAW;QACX,IAAI,gKAAY,OACd,OAAO;QAET,8DAA8D;QAC9D,OAAO,SAAS,OAAO;IACzB;AACF;AAMO,MAAM;IACX;;;GAGC,GACD,QAAQ,MAAM,EAAE,UAAU,EAAE;QAC5B,qDAAqD;QACnD,IAAI,kLACF;QAEF,+DAA+D;QAC/D,uBAAuB;QACvB,IAAI,qKAAiB,aACnB,OAAO;QAET,gEAAgE;QAChE,2DAA2D;QAC3D,IAAI,4JAAQ,YAAY,QAAQ,SAC9B,OAAO,aAAa,SAAS;QAE/B,mCAAmC;QACnC,OAAO,iKAAa;IACtB;AACF"}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 480, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/iso-2022-jp.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, floor } from '../utils'\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes'\n\n// 13.2 iso-2022-jp\n\n// 13.2.1 iso-2022-jp decoder\n/**\n * @implements {Decoder}\n */\nexport class ISO2022JPDecoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    /** @enum */\n    this.states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6,\n    }\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    this.iso2022jp_decoder_state = this.states.ASCII\n    this.iso2022jp_decoder_output_state = this.states.ASCII,\n    this.iso2022jp_lead = 0x00\n    this.iso2022jp_output_flag = false\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // switching on iso-2022-jp decoder state:\n    switch (this.iso2022jp_decoder_state) {\n    default:\n    case this.states.ASCII:\n    // ASCII\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return null\n      }\n\n      // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n      if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\n        && bite !== 0x0F && bite !== 0x1B) {\n      // Unset the iso-2022-jp output flag and return a code point\n      // whose value is byte.\n        this.iso2022jp_output_flag = false\n        return bite\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Return finished.\n        return finished\n      }\n\n      // Otherwise\n      // Unset the iso-2022-jp output flag and return error.\n      this.iso2022jp_output_flag = false\n      return decoderError(this.fatal)\n\n    case this.states.Roman:\n    // Roman\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return null\n      }\n\n      // 0x5C\n      if (bite === 0x5C) {\n      // Unset the iso-2022-jp output flag and return code point\n      // U+00A5.\n        this.iso2022jp_output_flag = false\n        return 0x00A5\n      }\n\n      // 0x7E\n      if (bite === 0x7E) {\n      // Unset the iso-2022-jp output flag and return code point\n      // U+203E.\n        this.iso2022jp_output_flag = false\n        return 0x203E\n      }\n\n      // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n      if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\n        && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n      // Unset the iso-2022-jp output flag and return a code point\n      // whose value is byte.\n        this.iso2022jp_output_flag = false\n        return bite\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Return finished.\n        return finished\n      }\n\n      // Otherwise\n      // Unset the iso-2022-jp output flag and return error.\n      this.iso2022jp_output_flag = false\n      return decoderError(this.fatal)\n\n    case this.states.Katakana:\n    // Katakana\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return null\n      }\n\n      // 0x21 to 0x5F\n      if (inRange(bite, 0x21, 0x5F)) {\n      // Unset the iso-2022-jp output flag and return a code point\n      // whose value is 0xFF61 − 0x21 + byte.\n        this.iso2022jp_output_flag = false\n        return 0xFF61 - 0x21 + bite\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Return finished.\n        return finished\n      }\n\n      // Otherwise\n      // Unset the iso-2022-jp output flag and return error.\n      this.iso2022jp_output_flag = false\n      return decoderError(this.fatal)\n\n    case this.states.LeadByte:\n    // Lead byte\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return null\n      }\n\n      // 0x21 to 0x7E\n      if (inRange(bite, 0x21, 0x7E)) {\n      // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n      // to byte, iso-2022-jp decoder state to trail byte, and\n      // return continue.\n        this.iso2022jp_output_flag = false\n        this.iso2022jp_lead = bite\n        this.iso2022jp_decoder_state = this.states.TrailByte\n        return null\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Return finished.\n        return finished\n      }\n\n      // Otherwise\n      // Unset the iso-2022-jp output flag and return error.\n      this.iso2022jp_output_flag = false\n      return decoderError(this.fatal)\n\n    case this.states.TrailByte:\n    // Trail byte\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return decoderError(this.fatal)\n      }\n\n      // 0x21 to 0x7E\n      if (inRange(bite, 0x21, 0x7E)) {\n      // 1. Set the iso-2022-jp decoder state to lead byte.\n        this.iso2022jp_decoder_state = this.states.LeadByte\n\n        // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n        const pointer = (this.iso2022jp_lead - 0x21) * 94 + bite - 0x21\n\n        // 3. Let code point be the index code point for pointer in\n        // index jis0208.\n        const code_point = indexCodePointFor(pointer, index('jis0208'))\n\n        // 4. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(this.fatal)\n\n        // 5. Return a code point whose value is code point.\n        return code_point\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Set the iso-2022-jp decoder state to lead byte, prepend\n      // byte to stream, and return error.\n        this.iso2022jp_decoder_state = this.states.LeadByte\n        stream.prepend(bite)\n        return decoderError(this.fatal)\n      }\n\n      // Otherwise\n      // Set iso-2022-jp decoder state to lead byte and return\n      // error.\n      this.iso2022jp_decoder_state = this.states.LeadByte\n      return decoderError(this.fatal)\n\n    case this.states.EscapeStart:\n    // Escape start\n\n      // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n      // byte, iso-2022-jp decoder state to escape, and return\n      // continue.\n      if (bite === 0x24 || bite === 0x28) {\n        this.iso2022jp_lead = bite\n        this.iso2022jp_decoder_state = this.states.Escape\n        return null\n      }\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite)\n\n      // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n      // decoder state to iso-2022-jp decoder output state, and\n      // return error.\n      this.iso2022jp_output_flag = false\n      this.iso2022jp_decoder_state = this.iso2022jp_decoder_output_state\n      return decoderError(this.fatal)\n\n    case this.states.Escape: {\n    // Escape\n\n      // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n      // 0x00.\n      const lead = this.iso2022jp_lead\n      this.iso2022jp_lead = 0x00\n\n      // 2. Let state be null.\n      let state = null\n\n      // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n      if (lead === 0x28 && bite === 0x42)\n        state = this.states.ASCII\n\n      // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n      if (lead === 0x28 && bite === 0x4A)\n        state = this.states.Roman\n\n      // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n      if (lead === 0x28 && bite === 0x49)\n        state = this.states.Katakana\n\n      // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n      // state to lead byte.\n      if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\n        state = this.states.LeadByte\n\n      // 7. If state is non-null, run these substeps:\n      if (state !== null) {\n      // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n      // output state to this.states.\n        this.iso2022jp_decoder_state = this.iso2022jp_decoder_state = state\n\n        // 2. Let output flag be the iso-2022-jp output flag.\n        const output_flag = this.iso2022jp_output_flag\n\n        // 3. Set the iso-2022-jp output flag.\n        this.iso2022jp_output_flag = true\n\n        // 4. Return continue, if output flag is unset, and error\n        // otherwise.\n        return !output_flag ? null : decoderError(this.fatal)\n      }\n\n      // 8. Prepend lead and byte to stream.\n      stream.prepend([lead, bite])\n\n      // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n      // decoder state to iso-2022-jp decoder output state and\n      // return error.\n      this.iso2022jp_output_flag = false\n      this.iso2022jp_decoder_state = this.iso2022jp_decoder_output_state\n      return decoderError(this.fatal)\n    }\n    }\n  }\n}\n\n// 13.2.2 iso-2022-jp encoder\n/**\n * @implements {Encoder}\n */\nexport class ISO2022JPEncoder {\n  constructor() {\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    this.states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2,\n    }\n    this.iso2022jp_state = this.states.ASCII\n  }\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n  // 1. If code point is end-of-stream and iso-2022-jp encoder\n  // state is not ASCII, prepend code point to stream, set\n  // iso-2022-jp encoder state to ASCII, and return three bytes\n  // 0x1B 0x28 0x42.\n    if (code_point === end_of_stream &&\n      this.iso2022jp_state !== this.states.ASCII) {\n      stream.prepend(code_point)\n      this.iso2022jp_state = this.states.ASCII\n      return [0x1B, 0x28, 0x42]\n    }\n\n    // 2. If code point is end-of-stream and iso-2022-jp encoder\n    // state is ASCII, return finished.\n    if (code_point === end_of_stream && this.iso2022jp_state === this.states.ASCII)\n      return finished\n\n    // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n    // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n    if ((this.iso2022jp_state === this.states.ASCII ||\n        this.iso2022jp_state === this.states.Roman) &&\n      (code_point === 0x000E || code_point === 0x000F ||\n        code_point === 0x001B)) {\n      return encoderError(0xFFFD)\n    }\n\n    // 4. If iso-2022-jp encoder state is ASCII and code point is an\n    // ASCII code point, return a byte whose value is code point.\n    if (this.iso2022jp_state === this.states.ASCII &&\n      isASCIICodePoint(code_point))\n      return code_point\n\n    // 5. If iso-2022-jp encoder state is Roman and code point is an\n    // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n    // or U+203E, run these substeps:\n    if (this.iso2022jp_state === this.states.Roman &&\n      ((isASCIICodePoint(code_point) &&\n        code_point !== 0x005C && code_point !== 0x007E) ||\n      (code_point == 0x00A5 || code_point == 0x203E))) {\n    // 1. If code point is an ASCII code point, return a byte\n    // whose value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point\n\n      // 2. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C\n\n      // 3. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E\n    }\n\n    // 6. If code point is an ASCII code point, and iso-2022-jp\n    // encoder state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (isASCIICodePoint(code_point) &&\n      this.iso2022jp_state !== this.states.ASCII) {\n      stream.prepend(code_point)\n      this.iso2022jp_state = this.states.ASCII\n      return [0x1B, 0x28, 0x42]\n    }\n\n    // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n    // encoder state is not Roman, prepend code point to stream, set\n    // iso-2022-jp encoder state to Roman, and return three bytes\n    // 0x1B 0x28 0x4A.\n    if ((code_point === 0x00A5 || code_point === 0x203E) &&\n      this.iso2022jp_state !== this.states.Roman) {\n      stream.prepend(code_point)\n      this.iso2022jp_state = this.states.Roman\n      return [0x1B, 0x28, 0x4A]\n    }\n\n    // 8. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212)\n      code_point = 0xFF0D\n\n    // 9. Let pointer be the index pointer for code point in index\n    // jis0208.\n    const pointer = indexPointerFor(code_point, index('jis0208'))\n\n    // 10. If pointer is null, return error with code point.\n    if (pointer === null)\n      return encoderError(code_point)\n\n    // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n    // point to stream, set iso-2022-jp encoder state to jis0208,\n    // and return three bytes 0x1B 0x24 0x42.\n    if (this.iso2022jp_state !== this.states.jis0208) {\n      stream.prepend(code_point)\n      this.iso2022jp_state = this.states.jis0208\n      return [0x1B, 0x24, 0x42]\n    }\n\n    // 12. Let lead be floor(pointer / 94) + 0x21.\n    const lead = floor(pointer / 94) + 0x21\n\n    // 13. Let trail be pointer % 94 + 0x21.\n    const trail = pointer % 94 + 0x21\n\n    // 14. Return two bytes whose values are lead and trail.\n    return [lead, trail]\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 847, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 852, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/euc-kr.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, isASCIIByte, floor } from '../utils'\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes'\n\n//\n// 14. Legacy multi-byte Korean encodings\n//\n\n// 14.1 euc-kr\n\n// 14.1.1 euc-kr decoder\n/**\n * @implements {Decoder}\n */\nexport class EUCKRDecoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n    this.euckr_lead = 0x00\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n    // euc-kr lead to 0x00 and return error.\n    if (bite === end_of_stream && this.euckr_lead !== 0) {\n      this.euckr_lead = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.euckr_lead === 0)\n      return finished\n\n    // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n    // pointer be null, set euc-kr lead to 0x00, and then run these\n    // substeps:\n    if (this.euckr_lead !== 0x00) {\n      const lead = this.euckr_lead\n      let pointer = null\n      this.euckr_lead = 0x00\n\n      // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n      // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n      if (inRange(bite, 0x41, 0xFE))\n        pointer = (lead - 0x81) * 190 + (bite - 0x41)\n\n      // 2. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index euc-kr otherwise.\n      const code_point = (pointer === null)\n        ? null : indexCodePointFor(pointer, index('euc-kr'))\n\n      // 3. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (pointer === null && isASCIIByte(bite))\n        stream.prepend(bite)\n\n      // 4. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 5. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // euc-kr lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.euckr_lead = bite\n      return null\n    }\n\n    // 6. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n// 14.1.2 euc-kr encoder\n/**\n * @implements {Encoder}\n */\nexport class EUCKREncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n  // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. Let pointer be the index pointer for code point in index\n    // euc-kr.\n    const pointer = indexPointerFor(code_point, index('euc-kr'))\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null)\n      return encoderError(code_point)\n\n    // 5. Let lead be floor(pointer / 190) + 0x81.\n    const lead = floor(pointer / 190) + 0x81\n\n    // 6. Let trail be pointer % 190 + 0x41.\n    const trail = (pointer % 190) + 0x41\n\n    // 7. Return two bytes whose values are lead and trail.\n    return [lead, trail]\n  }\n}"],"names":[],"mappings":";;;;;;;;;AAcO,MAAM;IACX,YAAY,OAAO,CAAE;QACnB,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,IAAI,CAAC,KAAK,GAAG;QACb,mEAAmE;QACnE,IAAI,CAAC,UAAU,GAAG;IACpB;IACA;;;GAGC,GACD,QAAQ,MAAM,EAAE,IAAI,EAAE;QACpB,+DAA+D;QAC/D,wCAAwC;QACxC,IAAI,8KAA0B,IAAI,CAAC,UAAU,KAAK,GAAG;YACnD,IAAI,CAAC,UAAU,GAAG;YAClB,OAAO,iKAAa,IAAI,CAAC,KAAK;QAChC;QAEA,8DAA8D;QAC9D,YAAY;QACZ,IAAI,8KAA0B,IAAI,CAAC,UAAU,KAAK,GAChD;QAEF,8DAA8D;QAC9D,+DAA+D;QAC/D,YAAY;QACZ,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM;YAC5B,MAAM,OAAO,IAAI,CAAC,UAAU;YAC5B,IAAI,UAAU;YACd,IAAI,CAAC,UAAU,GAAG;YAElB,0DAA0D;YAC1D,kDAAkD;YAClD,IAAI,4JAAQ,MAAM,MAAM,OACtB,UAAU,CAAC,OAAO,IAAI,IAAI,MAAM,CAAC,OAAO,IAAI;YAE9C,yDAAyD;YACzD,0DAA0D;YAC1D,MAAM,aAAa,AAAC,YAAY,OAC5B,OAAO,wKAAkB,SAAS,8JAAM;YAE5C,8DAA8D;YAC9D,kBAAkB;YAClB,IAAI,YAAY,QAAQ,gKAAY,OAClC,OAAO,OAAO,CAAC;YAEjB,0CAA0C;YAC1C,IAAI,eAAe,MACjB,OAAO,iKAAa,IAAI,CAAC,KAAK;YAEhC,oDAAoD;YACpD,OAAO;QACT;QAEA,+DAA+D;QAC/D,WAAW;QACX,IAAI,gKAAY,OACd,OAAO;QAET,0DAA0D;QAC1D,2CAA2C;QAC3C,IAAI,4JAAQ,MAAM,MAAM,OAAO;YAC7B,IAAI,CAAC,UAAU,GAAG;YAClB,OAAO;QACT;QAEA,mBAAmB;QACnB,OAAO,iKAAa,IAAI,CAAC,KAAK;IAChC;AACF;AAMO,MAAM;IACX;;;;GAIC,GACD,QAAQ,MAAM,EAAE,UAAU,EAAE;QAC5B,sDAAsD;QACpD,IAAI,kLACF;QAEF,+DAA+D;QAC/D,uBAAuB;QACvB,IAAI,qKAAiB,aACnB,OAAO;QAET,8DAA8D;QAC9D,UAAU;QACV,MAAM,UAAU,sKAAgB,YAAY,8JAAM;QAElD,uDAAuD;QACvD,IAAI,YAAY,MACd,OAAO,iKAAa;QAEtB,8CAA8C;QAC9C,MAAM,OAAO,0JAAM,UAAU,OAAO;QAEpC,wCAAwC;QACxC,MAAM,QAAQ,AAAC,UAAU,MAAO;QAEhC,uDAAuD;QACvD,OAAO;YAAC;YAAM;SAAM;IACtB;AACF"}},
    {"offset": {"line": 942, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 947, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/euc-jp.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, isASCIIByte, floor } from '../utils'\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes'\n\n//\n// 13. Legacy multi-byte Japanese encodings\n//\n\n// 13.1 euc-jp\n\n// 13.1.1 euc-jp decoder\n/**\n * @implements {Decoder}\n */\nexport class EUCJPDecoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    this.eucjp_jis0212_flag = false\n    this.eucjp_lead = 0x00\n  }\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n  // euc-jp lead to 0x00, and return error.\n    if (bite === end_of_stream && this.eucjp_lead !== 0x00) {\n      this.eucjp_lead = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.eucjp_lead === 0x00)\n      return finished\n\n    // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n    // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n    // point whose value is 0xFF61 − 0xA1 + byte.\n    if (this.eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n      this.eucjp_lead = 0x00\n      return 0xFF61 - 0xA1 + bite\n    }\n\n    // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n    // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n    // to byte, and return continue.\n    if (this.eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n      this.eucjp_jis0212_flag = true\n      this.eucjp_lead = bite\n      return null\n    }\n\n    // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n    // euc-jp lead to 0x00, and run these substeps:\n    if (this.eucjp_lead !== 0x00) {\n      const lead = this.eucjp_lead\n      this.eucjp_lead = 0x00\n\n      // 1. Let code point be null.\n      let code_point = null\n\n      // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n      // inclusive, set code point to the index code point for (lead\n      // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n      // jis0212 flag is unset and in index jis0212 otherwise.\n      if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n        code_point = indexCodePointFor(\n          (lead - 0xA1) * 94 + (bite - 0xA1),\n          index(!this.eucjp_jis0212_flag ? 'jis0208' : 'jis0212'))\n      }\n\n      // 3. Unset the euc-jp jis0212 flag.\n      this.eucjp_jis0212_flag = false\n\n      // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n      // prepend byte to stream.\n      if (!inRange(bite, 0xA1, 0xFE))\n        stream.prepend(bite)\n\n      // 5. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 6. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n    // inclusive, set euc-jp lead to byte and return continue.\n    if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n      this.eucjp_lead = bite\n      return null\n    }\n\n    // 8. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n// 13.1.2 euc-jp encoder\n/**\n * @implements {Encoder}\n */\nexport class EUCJPEncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n  // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00A5)\n      return 0x5C\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203E)\n      return 0x7E\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return two bytes whose values are 0x8E and code point −\n    // 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xFF61, 0xFF9F))\n      return [0x8E, code_point - 0xFF61 + 0xA1]\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212)\n      code_point = 0xFF0D\n\n    // 7. Let pointer be the index pointer for code point in index\n    // jis0208.\n    const pointer = indexPointerFor(code_point, index('jis0208'))\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null)\n      return encoderError(code_point)\n\n    // 9. Let lead be floor(pointer / 94) + 0xA1.\n    const lead = floor(pointer / 94) + 0xA1\n\n    // 10. Let trail be pointer % 94 + 0xA1.\n    const trail = pointer % 94 + 0xA1\n\n    // 11. Return two bytes whose values are lead and trail.\n    return [lead, trail]\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1069, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1074, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/big5.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, isASCIIByte, floor } from '../utils'\nimport index, { indexBig5PointerFor, indexCodePointFor } from '../indexes'\n\n//\n// 12. Legacy multi-byte Chinese (traditional) encodings\n//\n\n// 12.1 Big5\n\n// 12.1.1 Big5 decoder\n/**\n * @implements {Decoder}\n */\nexport class Big5Decoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    // Big5's decoder has an associated Big5 lead (initially 0x00).\n    this.Big5_lead = 0x00\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n  // Big5 lead to 0x00 and return error.\n    if (bite === end_of_stream && this.Big5_lead !== 0x00) {\n      this.Big5_lead = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.Big5_lead === 0x00)\n      return finished\n\n    // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n    // pointer be null, set Big5 lead to 0x00, and then run these\n    // substeps:\n    if (this.Big5_lead !== 0x00) {\n      const lead = this.Big5_lead\n      let pointer = null\n      this.Big5_lead = 0x00\n\n      // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n      // otherwise.\n      const offset = bite < 0x7F ? 0x40 : 0x62\n\n      // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\n        pointer = (lead - 0x81) * 157 + (bite - offset)\n\n      // 3. If there is a row in the table below whose first column\n      // is pointer, return the two code points listed in its second\n      // column\n      // Pointer | Code points\n      // --------+--------------\n      // 1133    | U+00CA U+0304\n      // 1135    | U+00CA U+030C\n      // 1164    | U+00EA U+0304\n      // 1166    | U+00EA U+030C\n      switch (pointer) {\n      case 1133: return [0x00CA, 0x0304]\n      case 1135: return [0x00CA, 0x030C]\n      case 1164: return [0x00EA, 0x0304]\n      case 1166: return [0x00EA, 0x030C]\n      }\n\n      // 4. Let code point be null if pointer is null and the index\n      // code point for pointer in index Big5 otherwise.\n      const code_point = (pointer === null) ? null :\n        indexCodePointFor(pointer, index('big5'))\n\n      // 5. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite))\n        stream.prepend(bite)\n\n      // 6. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 7. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n    // lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.Big5_lead = bite\n      return null\n    }\n\n    // 6. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n\n// 12.1.2 Big5 encoder\n/**\n * @implements {Encoder}\n */\nexport class Big5Encoder {\n  constructor() {\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     */\n    this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point\n\n      // 3. Let pointer be the index Big5 pointer for code point.\n      const pointer = indexBig5PointerFor(code_point)\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point)\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      const lead = floor(pointer / 157) + 0x81\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1)\n        return encoderError(code_point)\n\n      // 7. Let trail be pointer % 157.\n      const trail = pointer % 157\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      const offset = trail < 0x3F ? 0x40 : 0x62\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset]\n    }\n  }\n}"],"names":[],"mappings":";;;;;;;;;AAcO,MAAM;IACX,YAAY,OAAO,CAAE;QACnB,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,IAAI,CAAC,KAAK,GAAG;QACb,+DAA+D;QAC/D,IAAI,CAAC,SAAS,GAAG;IACnB;IACA;;;GAGC,GACD,QAAQ,MAAM,EAAE,IAAI,EAAE;QACtB,6DAA6D;QAC7D,sCAAsC;QACpC,IAAI,8KAA0B,IAAI,CAAC,SAAS,KAAK,MAAM;YACrD,IAAI,CAAC,SAAS,GAAG;YACjB,OAAO,iKAAa,IAAI,CAAC,KAAK;QAChC;QAEA,4DAA4D;QAC5D,YAAY;QACZ,IAAI,8KAA0B,IAAI,CAAC,SAAS,KAAK,MAC/C;QAEF,0DAA0D;QAC1D,6DAA6D;QAC7D,YAAY;QACZ,IAAI,IAAI,CAAC,SAAS,KAAK,MAAM;YAC3B,MAAM,OAAO,IAAI,CAAC,SAAS;YAC3B,IAAI,UAAU;YACd,IAAI,CAAC,SAAS,GAAG;YAEjB,2DAA2D;YAC3D,aAAa;YACb,MAAM,SAAS,OAAO,OAAO,OAAO;YAEpC,8DAA8D;YAC9D,2DAA2D;YAC3D,mBAAmB;YACnB,IAAI,4JAAQ,MAAM,MAAM,SAAS,4JAAQ,MAAM,MAAM,OACnD,UAAU,CAAC,OAAO,IAAI,IAAI,MAAM,CAAC,OAAO,MAAM;YAEhD,6DAA6D;YAC7D,8DAA8D;YAC9D,SAAS;YACT,wBAAwB;YACxB,0BAA0B;YAC1B,0BAA0B;YAC1B,0BAA0B;YAC1B,0BAA0B;YAC1B,0BAA0B;YAC1B,OAAQ;gBACR,KAAK;oBAAM,OAAO;wBAAC;wBAAQ;qBAAO;gBAClC,KAAK;oBAAM,OAAO;wBAAC;wBAAQ;qBAAO;gBAClC,KAAK;oBAAM,OAAO;wBAAC;wBAAQ;qBAAO;gBAClC,KAAK;oBAAM,OAAO;wBAAC;wBAAQ;qBAAO;YAClC;YAEA,6DAA6D;YAC7D,kDAAkD;YAClD,MAAM,aAAa,AAAC,YAAY,OAAQ,OACtC,wKAAkB,SAAS,8JAAM;YAEnC,8DAA8D;YAC9D,kBAAkB;YAClB,IAAI,eAAe,QAAQ,gKAAY,OACrC,OAAO,OAAO,CAAC;YAEjB,0CAA0C;YAC1C,IAAI,eAAe,MACjB,OAAO,iKAAa,IAAI,CAAC,KAAK;YAEhC,oDAAoD;YACpD,OAAO;QACT;QAEA,+DAA+D;QAC/D,WAAW;QACX,IAAI,gKAAY,OACd,OAAO;QAET,+DAA+D;QAC/D,oCAAoC;QACpC,IAAI,4JAAQ,MAAM,MAAM,OAAO;YAC7B,IAAI,CAAC,SAAS,GAAG;YACjB,OAAO;QACT;QAEA,mBAAmB;QACnB,OAAO,iKAAa,IAAI,CAAC,KAAK;IAChC;AACF;AAOO,MAAM;IACX,aAAc;QACZ;;;KAGC,GACD,IAAI,CAAC,OAAO,GAAG,SAAS,MAAM,EAAE,UAAU;YAC1C,sDAAsD;YACpD,IAAI,kLACF;YAEF,+DAA+D;YAC/D,uBAAuB;YACvB,IAAI,qKAAiB,aACnB,OAAO;YAET,2DAA2D;YAC3D,MAAM,UAAU,0KAAoB;YAEpC,uDAAuD;YACvD,IAAI,YAAY,MACd,OAAO,iKAAa;YAEtB,8CAA8C;YAC9C,MAAM,OAAO,0JAAM,UAAU,OAAO;YAEpC,8DAA8D;YAC9D,IAAI,OAAO,MACT,OAAO,iKAAa;YAEtB,iCAAiC;YACjC,MAAM,QAAQ,UAAU;YAExB,4DAA4D;YAC5D,aAAa;YACb,MAAM,SAAS,QAAQ,OAAO,OAAO;YAErC,6DAA6D;YAC7D,OAAO;gBAAC;gBAAM,QAAQ;aAAO;QAC/B;IACF;AACF"}},
    {"offset": {"line": 1204, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1209, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/gb18030.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, isASCIIByte, floor } from '../utils'\nimport index, {\n  indexGB18030RangesCodePointFor, indexGB18030RangesPointerFor,\n  indexCodePointFor, indexPointerFor } from '../indexes'\n\n// 11.2 gb18030\n\n// 11.2.1 gb18030 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nexport class GB18030Decoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    this.gb18030_first = 0x00\n    this.gb18030_second = 0x00,\n    this.gb18030_third = 0x00\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return The next code point(s) decoded, or null if not enough data exists in the input stream to decode a complete code point.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and gb18030 first, gb18030\n    // second, and gb18030 third are 0x00, return finished.\n    if (bite === end_of_stream && this.gb18030_first === 0x00 &&\n        this.gb18030_second === 0x00 && this.gb18030_third === 0x00) {\n      return finished\n    }\n    // 2. If byte is end-of-stream, and gb18030 first, gb18030\n    // second, or gb18030 third is not 0x00, set gb18030 first,\n    // gb18030 second, and gb18030 third to 0x00, and return error.\n    if (bite === end_of_stream &&\n        (this.gb18030_first !== 0x00 || this.gb18030_second !== 0x00 ||\n          this.gb18030_third !== 0x00)) {\n      this.gb18030_first = 0x00\n      this.gb18030_second = 0x00\n      this.gb18030_third = 0x00\n      decoderError(this.fatal)\n    }\n    var code_point\n    // 3. If gb18030 third is not 0x00, run these substeps:\n    if (this.gb18030_third !== 0x00) {\n      // 1. Let code point be null.\n      code_point = null\n      // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n      // code point to the index gb18030 ranges code point for\n      // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n      // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n      if (inRange(bite, 0x30, 0x39)) {\n        code_point = indexGB18030RangesCodePointFor(\n          (((this.gb18030_first - 0x81) * 10 + this.gb18030_second - 0x30) * 126 +\n              this.gb18030_third - 0x81) * 10 + bite - 0x30)\n      }\n\n      // 3. Let buffer be a byte sequence consisting of gb18030\n      // second, gb18030 third, and byte, in order.\n      var buffer = [this.gb18030_second, this.gb18030_third, bite]\n\n      // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n      // 0x00.\n      this.gb18030_first = 0x00\n      this.gb18030_second = 0x00\n      this.gb18030_third = 0x00\n\n      // 5. If code point is null, prepend buffer to stream and\n      // return error.\n      if (code_point === null) {\n        stream.prepend(buffer)\n        return decoderError(this.fatal)\n      }\n\n      // 6. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 4. If gb18030 second is not 0x00, run these substeps:\n    if (this.gb18030_second !== 0x00) {\n      // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 third to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        this.gb18030_third = bite\n        return null\n      }\n\n      // 2. Prepend gb18030 second followed by byte to stream, set\n      // gb18030 first and gb18030 second to 0x00, and return error.\n      stream.prepend([this.gb18030_second, bite])\n      this.gb18030_first = 0x00\n      this.gb18030_second = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 5. If gb18030 first is not 0x00, run these substeps:\n    if (this.gb18030_first !== 0x00) {\n      // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n      // gb18030 second to byte and return continue.\n      if (inRange(bite, 0x30, 0x39)) {\n        this.gb18030_second = bite\n        return null\n      }\n\n      // 2. Let lead be gb18030 first, let pointer be null, and set\n      // gb18030 first to 0x00.\n      var lead = this.gb18030_first\n      var pointer = null\n      this.gb18030_first = 0x00\n\n      // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n      // otherwise.\n      var offset = bite < 0x7F ? 0x40 : 0x41\n\n      // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\n        pointer = (lead - 0x81) * 190 + (bite - offset)\n\n      // 5. Let code point be null if pointer is null and the index\n      // code point for pointer in index gb18030 otherwise.\n      code_point = pointer === null ? null :\n        indexCodePointFor(pointer, index('gb18030'))\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite))\n        stream.prepend(bite)\n\n      // 7. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 8. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 7. If byte is 0x80, return code point U+20AC.\n    if (bite === 0x80)\n      return 0x20AC\n\n    // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // gb18030 first to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.gb18030_first = bite\n      return null\n    }\n\n    // 9. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n// 11.2.2 gb18030 encoder\n/**\n * @implements {Encoder}\n */\nexport class GB18030Encoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. If code point is U+E5E5, return error with code point.\n    if (code_point === 0xE5E5)\n      return encoderError(code_point)\n\n    // 4. If the gbk flag is set and code point is U+20AC, return\n    // byte 0x80.\n    if (this.gbk_flag && code_point === 0x20AC)\n      return 0x80\n\n    // 5. Let pointer be the index pointer for code point in index\n    // gb18030.\n    var pointer = indexPointerFor(code_point, index('gb18030'))\n\n    // 6. If pointer is not null, run these substeps:\n    if (pointer !== null) {\n    // 1. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81\n\n      // 2. Let trail be pointer % 190.\n      var trail = pointer % 190\n\n      // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x41\n\n      // 4. Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset]\n    }\n\n    // 7. If gbk flag is set, return error with code point.\n    if (this.gbk_flag)\n      return encoderError(code_point)\n\n    // 8. Set pointer to the index gb18030 ranges pointer for code\n    // point.\n    pointer = indexGB18030RangesPointerFor(code_point)\n\n    // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n    var byte1 = floor(pointer / 10 / 126 / 10)\n\n    // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n    pointer = pointer - byte1 * 10 * 126 * 10\n\n    // 11. Let byte2 be floor(pointer / 10 / 126).\n    var byte2 = floor(pointer / 10 / 126)\n\n    // 12. Set pointer to pointer − byte2 × 10 × 126.\n    pointer = pointer - byte2 * 10 * 126\n\n    // 13. Let byte3 be floor(pointer / 10).\n    var byte3 = floor(pointer / 10)\n\n    // 14. Let byte4 be pointer − byte3 × 10.\n    var byte4 = pointer - byte3 * 10\n\n    // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n    // 0x30, byte3 + 0x81, byte4 + 0x30.\n    return [byte1 + 0x81,\n      byte2 + 0x30,\n      byte3 + 0x81,\n      byte4 + 0x30]\n  }\n\n  constructor(options = {}, gbk_flag = false) {\n    // gb18030's decoder has an associated gbk flag (initially unset).\n    this.gbk_flag = gbk_flag\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;AAcO,MAAM;IACX,YAAY,OAAO,CAAE;QACnB,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,IAAI,CAAC,KAAK,GAAG;QACb,6DAA6D;QAC7D,kDAAkD;QAClD,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,cAAc,GAAG,MACtB,IAAI,CAAC,aAAa,GAAG;IACvB;IACA;;;;GAIC,GACD,QAAQ,MAAM,EAAE,IAAI,EAAE;QACpB,yDAAyD;QACzD,uDAAuD;QACvD,IAAI,8KAA0B,IAAI,CAAC,aAAa,KAAK,QACjD,IAAI,CAAC,cAAc,KAAK,QAAQ,IAAI,CAAC,aAAa,KAAK,MAAM;YAC/D;QACF;QACA,0DAA0D;QAC1D,2DAA2D;QAC3D,+DAA+D;QAC/D,IAAI,8KACA,CAAC,IAAI,CAAC,aAAa,KAAK,QAAQ,IAAI,CAAC,cAAc,KAAK,QACtD,IAAI,CAAC,aAAa,KAAK,IAAI,GAAG;YAClC,IAAI,CAAC,aAAa,GAAG;YACrB,IAAI,CAAC,cAAc,GAAG;YACtB,IAAI,CAAC,aAAa,GAAG;YACrB,iKAAa,IAAI,CAAC,KAAK;QACzB;QACA,IAAI;QACJ,uDAAuD;QACvD,IAAI,IAAI,CAAC,aAAa,KAAK,MAAM;YAC/B,6BAA6B;YAC7B,aAAa;YACb,0DAA0D;YAC1D,wDAAwD;YACxD,2DAA2D;YAC3D,kDAAkD;YAClD,IAAI,4JAAQ,MAAM,MAAM,OAAO;gBAC7B,aAAa,qLACX,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,IAAI,KAAK,IAAI,CAAC,cAAc,GAAG,IAAI,IAAI,MAC/D,IAAI,CAAC,aAAa,GAAG,IAAI,IAAI,KAAK,OAAO;YACjD;YAEA,yDAAyD;YACzD,6CAA6C;YAC7C,IAAI,SAAS;gBAAC,IAAI,CAAC,cAAc;gBAAE,IAAI,CAAC,aAAa;gBAAE;aAAK;YAE5D,6DAA6D;YAC7D,QAAQ;YACR,IAAI,CAAC,aAAa,GAAG;YACrB,IAAI,CAAC,cAAc,GAAG;YACtB,IAAI,CAAC,aAAa,GAAG;YAErB,yDAAyD;YACzD,gBAAgB;YAChB,IAAI,eAAe,MAAM;gBACvB,OAAO,OAAO,CAAC;gBACf,OAAO,iKAAa,IAAI,CAAC,KAAK;YAChC;YAEA,oDAAoD;YACpD,OAAO;QACT;QAEA,wDAAwD;QACxD,IAAI,IAAI,CAAC,cAAc,KAAK,MAAM;YAChC,0DAA0D;YAC1D,6CAA6C;YAC7C,IAAI,4JAAQ,MAAM,MAAM,OAAO;gBAC7B,IAAI,CAAC,aAAa,GAAG;gBACrB,OAAO;YACT;YAEA,4DAA4D;YAC5D,8DAA8D;YAC9D,OAAO,OAAO,CAAC;gBAAC,IAAI,CAAC,cAAc;gBAAE;aAAK;YAC1C,IAAI,CAAC,aAAa,GAAG;YACrB,IAAI,CAAC,cAAc,GAAG;YACtB,OAAO,iKAAa,IAAI,CAAC,KAAK;QAChC;QAEA,uDAAuD;QACvD,IAAI,IAAI,CAAC,aAAa,KAAK,MAAM;YAC/B,0DAA0D;YAC1D,8CAA8C;YAC9C,IAAI,4JAAQ,MAAM,MAAM,OAAO;gBAC7B,IAAI,CAAC,cAAc,GAAG;gBACtB,OAAO;YACT;YAEA,6DAA6D;YAC7D,yBAAyB;YACzB,IAAI,OAAO,IAAI,CAAC,aAAa;YAC7B,IAAI,UAAU;YACd,IAAI,CAAC,aAAa,GAAG;YAErB,2DAA2D;YAC3D,aAAa;YACb,IAAI,SAAS,OAAO,OAAO,OAAO;YAElC,8DAA8D;YAC9D,2DAA2D;YAC3D,mBAAmB;YACnB,IAAI,4JAAQ,MAAM,MAAM,SAAS,4JAAQ,MAAM,MAAM,OACnD,UAAU,CAAC,OAAO,IAAI,IAAI,MAAM,CAAC,OAAO,MAAM;YAEhD,6DAA6D;YAC7D,qDAAqD;YACrD,aAAa,YAAY,OAAO,OAC9B,wKAAkB,SAAS,8JAAM;YAEnC,8DAA8D;YAC9D,kBAAkB;YAClB,IAAI,eAAe,QAAQ,gKAAY,OACrC,OAAO,OAAO,CAAC;YAEjB,0CAA0C;YAC1C,IAAI,eAAe,MACjB,OAAO,iKAAa,IAAI,CAAC,KAAK;YAEhC,oDAAoD;YACpD,OAAO;QACT;QAEA,+DAA+D;QAC/D,WAAW;QACX,IAAI,gKAAY,OACd,OAAO;QAET,gDAAgD;QAChD,IAAI,SAAS,MACX,OAAO;QAET,0DAA0D;QAC1D,6CAA6C;QAC7C,IAAI,4JAAQ,MAAM,MAAM,OAAO;YAC7B,IAAI,CAAC,aAAa,GAAG;YACrB,OAAO;QACT;QAEA,mBAAmB;QACnB,OAAO,iKAAa,IAAI,CAAC,KAAK;IAChC;AACF;AAMO,MAAM;IACX;;;;GAIC,GACD,QAAQ,MAAM,EAAE,UAAU,EAAE;QAC1B,sDAAsD;QACtD,IAAI,kLACF;QAEF,+DAA+D;QAC/D,uBAAuB;QACvB,IAAI,qKAAiB,aACnB,OAAO;QAET,4DAA4D;QAC5D,IAAI,eAAe,QACjB,OAAO,iKAAa;QAEtB,6DAA6D;QAC7D,aAAa;QACb,IAAI,IAAI,CAAC,QAAQ,IAAI,eAAe,QAClC,OAAO;QAET,8DAA8D;QAC9D,WAAW;QACX,IAAI,UAAU,sKAAgB,YAAY,8JAAM;QAEhD,iDAAiD;QACjD,IAAI,YAAY,MAAM;YACtB,8CAA8C;YAC5C,IAAI,OAAO,0JAAM,UAAU,OAAO;YAElC,iCAAiC;YACjC,IAAI,QAAQ,UAAU;YAEtB,uEAAuE;YACvE,IAAI,SAAS,QAAQ,OAAO,OAAO;YAEnC,gEAAgE;YAChE,OAAO;gBAAC;gBAAM,QAAQ;aAAO;QAC/B;QAEA,uDAAuD;QACvD,IAAI,IAAI,CAAC,QAAQ,EACf,OAAO,iKAAa;QAEtB,8DAA8D;QAC9D,SAAS;QACT,UAAU,mLAA6B;QAEvC,kDAAkD;QAClD,IAAI,QAAQ,0JAAM,UAAU,KAAK,MAAM;QAEvC,sDAAsD;QACtD,UAAU,UAAU,QAAQ,KAAK,MAAM;QAEvC,8CAA8C;QAC9C,IAAI,QAAQ,0JAAM,UAAU,KAAK;QAEjC,iDAAiD;QACjD,UAAU,UAAU,QAAQ,KAAK;QAEjC,wCAAwC;QACxC,IAAI,QAAQ,0JAAM,UAAU;QAE5B,yCAAyC;QACzC,IAAI,QAAQ,UAAU,QAAQ;QAE9B,+DAA+D;QAC/D,oCAAoC;QACpC,OAAO;YAAC,QAAQ;YACd,QAAQ;YACR,QAAQ;YACR,QAAQ;SAAK;IACjB;IAEA,YAAY,UAAU,CAAC,CAAC,EAAE,WAAW,KAAK,CAAE;QAC1C,kEAAkE;QAClE,IAAI,CAAC,QAAQ,GAAG;IAClB;AACF"}},
    {"offset": {"line": 1407, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1412, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/utf16.js"],"sourcesContent":["import { inRange, decoderError, end_of_stream, finished, convertCodeUnitToBytes } from '../utils'\n\n// 15.2.1 shared utf-16 decoder\n\n/**\n * @implements {Decoder}\n */\nexport class UTF16Decoder {\n  /**\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  constructor(utf16_be, options) {\n    const { fatal } = options\n    this.utf16_be = utf16_be\n    this.fatal = fatal\n    this.utf16_lead_byte = null\n    this.utf16_lead_surrogate = null\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream and either utf-16 lead byte or\n  // utf-16 lead surrogate is not null, set utf-16 lead byte and\n  // utf-16 lead surrogate to null, and return error.\n    if (bite === end_of_stream && (this.utf16_lead_byte !== null ||\n                            this.utf16_lead_surrogate !== null)) {\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n    // lead surrogate are null, return finished.\n    if (bite === end_of_stream && this.utf16_lead_byte === null &&\n      this.utf16_lead_surrogate === null) {\n      return finished\n    }\n\n    // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n    // and return continue.\n    if (this.utf16_lead_byte === null) {\n      this.utf16_lead_byte = bite\n      return null\n    }\n\n    // 4. Let code unit be the result of:\n    let code_unit\n    if (this.utf16_be) {\n    // utf-16be decoder flag is set\n    //   (utf-16 lead byte << 8) + byte.\n      code_unit = (this.utf16_lead_byte << 8) + bite\n    } else {\n    // utf-16be decoder flag is unset\n    //   (byte << 8) + utf-16 lead byte.\n      code_unit = (bite << 8) + this.utf16_lead_byte\n    }\n    // Then set utf-16 lead byte to null.\n    this.utf16_lead_byte = null\n\n    // 5. If utf-16 lead surrogate is not null, let lead surrogate\n    // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n    // and then run these substeps:\n    if (this.utf16_lead_surrogate !== null) {\n      const lead_surrogate = this.utf16_lead_surrogate\n      this.utf16_lead_surrogate = null\n\n      // 1. If code unit is in the range U+DC00 to U+DFFF,\n      // inclusive, return a code point whose value is 0x10000 +\n      // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n      if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n        return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +\n          (code_unit - 0xDC00)\n      }\n\n      // 2. Prepend the sequence resulting of converting code unit\n      // to bytes using utf-16be decoder flag to stream and return\n      // error.\n      stream.prepend(convertCodeUnitToBytes(code_unit, this.utf16_be))\n      return decoderError(this.fatal)\n    }\n\n    // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n    // set utf-16 lead surrogate to code unit and return continue.\n    if (inRange(code_unit, 0xD800, 0xDBFF)) {\n      this.utf16_lead_surrogate = code_unit\n      return null\n    }\n\n    // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n    // return error.\n    if (inRange(code_unit, 0xDC00, 0xDFFF))\n      return decoderError(this.fatal)\n\n    // 8. Return code point code unit.\n    return code_unit\n  }\n}\n\n// 15.2.2 shared utf-16 encoder\n/**\n * @implements {Encoder}\n */\nexport class UTF16Encoder {\n  /**\n   * @param {boolean} [utf16_be] True if big-endian, false if little-endian.\n   */\n  constructor(utf16_be = false) {\n    this.utf16_be = utf16_be\n  }\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n    // return the sequence resulting of converting code point to\n    // bytes using utf-16be encoder flag.\n    if (inRange(code_point, 0x0000, 0xFFFF))\n      return convertCodeUnitToBytes(code_point, this.utf16_be)\n\n    // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n    // converted to bytes using utf-16be encoder flag.\n    const lead = convertCodeUnitToBytes(\n      ((code_point - 0x10000) >> 10) + 0xD800, this.utf16_be)\n\n    // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n    // converted to bytes using utf-16be encoder flag.\n    const trail = convertCodeUnitToBytes(\n      ((code_point - 0x10000) & 0x3FF) + 0xDC00, this.utf16_be)\n\n    // 5. Return a byte sequence of lead followed by trail.\n    return lead.concat(trail)\n  }\n}"],"names":[],"mappings":";;;;;;;AAOO,MAAM;IACX;;;GAGC,GACD,YAAY,QAAQ,EAAE,OAAO,CAAE;QAC7B,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,eAAe,GAAG;QACvB,IAAI,CAAC,oBAAoB,GAAG;IAC9B;IACA;;;GAGC,GACD,QAAQ,MAAM,EAAE,IAAI,EAAE;QACtB,6DAA6D;QAC7D,8DAA8D;QAC9D,mDAAmD;QACjD,IAAI,8KAA0B,CAAC,IAAI,CAAC,eAAe,KAAK,QAChC,IAAI,CAAC,oBAAoB,KAAK,IAAI,GAAG;YAC3D,OAAO,iKAAa,IAAI,CAAC,KAAK;QAChC;QAEA,8DAA8D;QAC9D,4CAA4C;QAC5C,IAAI,8KAA0B,IAAI,CAAC,eAAe,KAAK,QACrD,IAAI,CAAC,oBAAoB,KAAK,MAAM;YACpC;QACF;QAEA,+DAA+D;QAC/D,uBAAuB;QACvB,IAAI,IAAI,CAAC,eAAe,KAAK,MAAM;YACjC,IAAI,CAAC,eAAe,GAAG;YACvB,OAAO;QACT;QAEA,qCAAqC;QACrC,IAAI;QACJ,IAAI,IAAI,CAAC,QAAQ,EAAE;YACnB,+BAA+B;YAC/B,oCAAoC;YAClC,YAAY,CAAC,IAAI,CAAC,eAAe,IAAI,CAAC,IAAI;QAC5C,OAAO;YACP,iCAAiC;YACjC,oCAAoC;YAClC,YAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,eAAe;QAChD;QACA,qCAAqC;QACrC,IAAI,CAAC,eAAe,GAAG;QAEvB,8DAA8D;QAC9D,+DAA+D;QAC/D,+BAA+B;QAC/B,IAAI,IAAI,CAAC,oBAAoB,KAAK,MAAM;YACtC,MAAM,iBAAiB,IAAI,CAAC,oBAAoB;YAChD,IAAI,CAAC,oBAAoB,GAAG;YAE5B,oDAAoD;YACpD,0DAA0D;YAC1D,4DAA4D;YAC5D,IAAI,4JAAQ,WAAW,QAAQ,SAAS;gBACtC,OAAO,UAAU,CAAC,iBAAiB,MAAM,IAAI,QAC3C,CAAC,YAAY,MAAM;YACvB;YAEA,4DAA4D;YAC5D,4DAA4D;YAC5D,SAAS;YACT,OAAO,OAAO,CAAC,2KAAuB,WAAW,IAAI,CAAC,QAAQ;YAC9D,OAAO,iKAAa,IAAI,CAAC,KAAK;QAChC;QAEA,+DAA+D;QAC/D,8DAA8D;QAC9D,IAAI,4JAAQ,WAAW,QAAQ,SAAS;YACtC,IAAI,CAAC,oBAAoB,GAAG;YAC5B,OAAO;QACT;QAEA,+DAA+D;QAC/D,gBAAgB;QAChB,IAAI,4JAAQ,WAAW,QAAQ,SAC7B,OAAO,iKAAa,IAAI,CAAC,KAAK;QAEhC,kCAAkC;QAClC,OAAO;IACT;AACF;AAMO,MAAM;IACX;;GAEC,GACD,YAAY,WAAW,KAAK,CAAE;QAC5B,IAAI,CAAC,QAAQ,GAAG;IAClB;IACA;;;GAGC,GACD,QAAQ,MAAM,EAAE,UAAU,EAAE;QAC1B,sDAAsD;QACtD,IAAI,kLACF;QAEF,gEAAgE;QAChE,4DAA4D;QAC5D,qCAAqC;QACrC,IAAI,4JAAQ,YAAY,QAAQ,SAC9B,OAAO,2KAAuB,YAAY,IAAI,CAAC,QAAQ;QAEzD,0DAA0D;QAC1D,kDAAkD;QAClD,MAAM,OAAO,2KACX,CAAC,AAAC,aAAa,WAAY,EAAE,IAAI,QAAQ,IAAI,CAAC,QAAQ;QAExD,6DAA6D;QAC7D,kDAAkD;QAClD,MAAM,QAAQ,2KACZ,CAAC,AAAC,aAAa,UAAW,KAAK,IAAI,QAAQ,IAAI,CAAC,QAAQ;QAE1D,uDAAuD;QACvD,OAAO,KAAK,MAAM,CAAC;IACrB;AACF"}},
    {"offset": {"line": 1521, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1526, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/implementations/utf8.js"],"sourcesContent":["import { inRange, decoderError, isASCIICodePoint,\n  end_of_stream, finished } from '../utils'\n\n/**\n * @implements {Decoder}\n */\nexport class UTF8Decoder {\n  /**\n   * @param {{fatal: boolean}} options\n   */\n  constructor(options) {\n    const { fatal } = options\n\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    let /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0\n        return decoderError(fatal)\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite\n        }\n\n        // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1\n\n          // 2. Set UTF-8 code point to byte & 0x1F.\n          utf8_code_point = bite & 0x1F\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0)\n            utf8_lower_boundary = 0xA0\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED)\n            utf8_upper_boundary = 0x9F\n          // 3. Set utf-8 bytes needed to 2.\n          utf8_bytes_needed = 2\n          // 4. Set UTF-8 code point to byte & 0xF.\n          utf8_code_point = bite & 0xF\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0)\n            utf8_lower_boundary = 0x90\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4)\n            utf8_upper_boundary = 0x8F\n          // 3. Set utf-8 bytes needed to 3.\n          utf8_bytes_needed = 3\n          // 4. Set UTF-8 code point to byte & 0x7.\n          utf8_code_point = bite & 0x7\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal)\n        }\n\n        // Return continue.\n        return null\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0\n        utf8_lower_boundary = 0x80\n        utf8_upper_boundary = 0xBF\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite)\n\n        // 3. Return error.\n        return decoderError(fatal)\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80\n      utf8_upper_boundary = 0xBF\n\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F)\n\n      // 7. Increase utf-8 bytes seen by one.\n      utf8_bytes_seen += 1\n\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed)\n        return null\n\n      // 9. Let code point be utf-8 code point.\n      var code_point = utf8_code_point\n\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0\n\n      // 11. Return a code point whose value is code point.\n      return code_point\n    }\n  }\n}\n\n// 9.1.2 utf-8 encoder\n\n/**\n * @implements {Encoder}\n */\nexport class UTF8Encoder {\n  constructor() {\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1\n        offset = 0xC0\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2\n        offset = 0xE0\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3\n        offset = 0xF0\n      }\n\n      // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n      var bytes = [(code_point >> (6 * count)) + offset]\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> (6 * (count - 1))\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | (temp & 0x3F))\n\n        // 3. Decrease count by one.\n        count -= 1\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes\n    }\n  }\n}"],"names":[],"mappings":";;;;;;;AAMO,MAAM;IACX;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,MAAM,EAAE,KAAK,EAAE,GAAG;QAElB,8DAA8D;QAC9D,gEAAgE;QAChE,8DAA8D;QAC9D,oBAAoB;QACpB,IAAI,mBAAmB,GAAG,kBAAkB,GAC1C,mBAAmB,GAAG,kBAAkB,GACxC,mBAAmB,GAAG,oBAAoB,GAC1C,mBAAmB,GAAG,sBAAsB,MAC5C,mBAAmB,GAAG,sBAAsB;QAE9C;;;;;;KAMC,GACD,IAAI,CAAC,OAAO,GAAG,SAAS,MAAM,EAAE,IAAI;YAClC,+DAA+D;YAC/D,gDAAgD;YAChD,IAAI,8KAA0B,sBAAsB,GAAG;gBACrD,oBAAoB;gBACpB,OAAO,iKAAa;YACtB;YAEA,gDAAgD;YAChD,IAAI,4KACF;YAEF,gDAAgD;YAChD,IAAI,sBAAsB,GAAG;gBAC3B,eAAe;gBACf,IAAI,4JAAQ,MAAM,MAAM,OAAO;oBAC7B,2CAA2C;oBAC3C,OAAO;gBACT,OAGK,IAAI,4JAAQ,MAAM,MAAM,OAAO;oBAClC,kCAAkC;oBAClC,oBAAoB;oBAEpB,0CAA0C;oBAC1C,kBAAkB,OAAO;gBAC3B,OAGK,IAAI,4JAAQ,MAAM,MAAM,OAAO;oBAClC,wDAAwD;oBACxD,IAAI,SAAS,MACX,sBAAsB;oBACxB,wDAAwD;oBACxD,IAAI,SAAS,MACX,sBAAsB;oBACxB,kCAAkC;oBAClC,oBAAoB;oBACpB,yCAAyC;oBACzC,kBAAkB,OAAO;gBAC3B,OAGK,IAAI,4JAAQ,MAAM,MAAM,OAAO;oBAClC,wDAAwD;oBACxD,IAAI,SAAS,MACX,sBAAsB;oBACxB,wDAAwD;oBACxD,IAAI,SAAS,MACX,sBAAsB;oBACxB,kCAAkC;oBAClC,oBAAoB;oBACpB,yCAAyC;oBACzC,kBAAkB,OAAO;gBAC3B,OAGK;oBACH,gBAAgB;oBAChB,OAAO,iKAAa;gBACtB;gBAEA,mBAAmB;gBACnB,OAAO;YACT;YAEA,+DAA+D;YAC/D,iDAAiD;YACjD,IAAI,CAAC,4JAAQ,MAAM,qBAAqB,sBAAsB;gBAC5D,yDAAyD;gBACzD,6DAA6D;gBAC7D,gCAAgC;gBAChC,kBAAkB,oBAAoB,kBAAkB;gBACxD,sBAAsB;gBACtB,sBAAsB;gBAEtB,6BAA6B;gBAC7B,OAAO,OAAO,CAAC;gBAEf,mBAAmB;gBACnB,OAAO,iKAAa;YACtB;YAEA,+DAA+D;YAC/D,WAAW;YACX,sBAAsB;YACtB,sBAAsB;YAEtB,+DAA+D;YAC/D,QAAQ;YACR,kBAAkB,AAAC,mBAAmB,IAAM,OAAO;YAEnD,uCAAuC;YACvC,mBAAmB;YAEnB,6DAA6D;YAC7D,YAAY;YACZ,IAAI,oBAAoB,mBACtB,OAAO;YAET,yCAAyC;YACzC,IAAI,aAAa;YAEjB,gEAAgE;YAChE,aAAa;YACb,kBAAkB,oBAAoB,kBAAkB;YAExD,qDAAqD;YACrD,OAAO;QACT;IACF;AACF;AAOO,MAAM;IACX,aAAc;QACZ;;;;KAIC,GACD,IAAI,CAAC,OAAO,GAAG,SAAS,MAAM,EAAE,UAAU;YACxC,sDAAsD;YACtD,IAAI,kLACF;YAEF,+DAA+D;YAC/D,uBAAuB;YACvB,IAAI,qKAAiB,aACnB,OAAO;YAET,+DAA+D;YAC/D,IAAI,OAAO;YACX,+BAA+B;YAC/B,IAAI,4JAAQ,YAAY,QAAQ,SAAS;gBACvC,aAAa;gBACb,QAAQ;gBACR,SAAS;YACX,OAEK,IAAI,4JAAQ,YAAY,QAAQ,SAAS;gBAC5C,aAAa;gBACb,QAAQ;gBACR,SAAS;YACX,OAEK,IAAI,4JAAQ,YAAY,SAAS,WAAW;gBAC/C,aAAa;gBACb,QAAQ;gBACR,SAAS;YACX;YAEA,4DAA4D;YAC5D,kCAAkC;YAClC,IAAI,QAAQ;gBAAC,CAAC,cAAe,IAAI,KAAM,IAAI;aAAO;YAElD,uDAAuD;YACvD,MAAO,QAAQ,EAAG;gBAChB,kDAAkD;gBAClD,IAAI,OAAO,cAAe,IAAI,CAAC,QAAQ,CAAC;gBAExC,2CAA2C;gBAC3C,MAAM,IAAI,CAAC,OAAQ,OAAO;gBAE1B,4BAA4B;gBAC5B,SAAS;YACX;YAEA,mCAAmC;YACnC,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 1677, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1682, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/encodings.js"],"sourcesContent":["/**\n * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n */\nconst encodings = [\n  {\n    encodings: [\n      {\n        labels: [\n          \"unicode-1-1-utf-8\",\n          \"utf-8\",\n          \"utf8\",\n        ],\n        name: \"UTF-8\",\n      },\n    ],\n    heading: \"The Encoding\",\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          \"866\",\n          \"cp866\",\n          \"csibm866\",\n          \"ibm866\",\n        ],\n        name: \"IBM866\",\n      },\n      {\n        labels: [\n          \"csisolatin2\",\n          \"iso-8859-2\",\n          \"iso-ir-101\",\n          \"iso8859-2\",\n          \"iso88592\",\n          \"iso_8859-2\",\n          \"iso_8859-2:1987\",\n          \"l2\",\n          \"latin2\",\n        ],\n        name: \"ISO-8859-2\",\n      },\n      {\n        labels: [\n          \"csisolatin3\",\n          \"iso-8859-3\",\n          \"iso-ir-109\",\n          \"iso8859-3\",\n          \"iso88593\",\n          \"iso_8859-3\",\n          \"iso_8859-3:1988\",\n          \"l3\",\n          \"latin3\",\n        ],\n        name: \"ISO-8859-3\",\n      },\n      {\n        labels: [\n          \"csisolatin4\",\n          \"iso-8859-4\",\n          \"iso-ir-110\",\n          \"iso8859-4\",\n          \"iso88594\",\n          \"iso_8859-4\",\n          \"iso_8859-4:1988\",\n          \"l4\",\n          \"latin4\",\n        ],\n        name: \"ISO-8859-4\",\n      },\n      {\n        labels: [\n          \"csisolatincyrillic\",\n          \"cyrillic\",\n          \"iso-8859-5\",\n          \"iso-ir-144\",\n          \"iso8859-5\",\n          \"iso88595\",\n          \"iso_8859-5\",\n          \"iso_8859-5:1988\",\n        ],\n        name: \"ISO-8859-5\",\n      },\n      {\n        labels: [\n          \"arabic\",\n          \"asmo-708\",\n          \"csiso88596e\",\n          \"csiso88596i\",\n          \"csisolatinarabic\",\n          \"ecma-114\",\n          \"iso-8859-6\",\n          \"iso-8859-6-e\",\n          \"iso-8859-6-i\",\n          \"iso-ir-127\",\n          \"iso8859-6\",\n          \"iso88596\",\n          \"iso_8859-6\",\n          \"iso_8859-6:1987\",\n        ],\n        name: \"ISO-8859-6\",\n      },\n      {\n        labels: [\n          \"csisolatingreek\",\n          \"ecma-118\",\n          \"elot_928\",\n          \"greek\",\n          \"greek8\",\n          \"iso-8859-7\",\n          \"iso-ir-126\",\n          \"iso8859-7\",\n          \"iso88597\",\n          \"iso_8859-7\",\n          \"iso_8859-7:1987\",\n          \"sun_eu_greek\",\n        ],\n        name: \"ISO-8859-7\",\n      },\n      {\n        labels: [\n          \"csiso88598e\",\n          \"csisolatinhebrew\",\n          \"hebrew\",\n          \"iso-8859-8\",\n          \"iso-8859-8-e\",\n          \"iso-ir-138\",\n          \"iso8859-8\",\n          \"iso88598\",\n          \"iso_8859-8\",\n          \"iso_8859-8:1988\",\n          \"visual\",\n        ],\n        name: \"ISO-8859-8\",\n      },\n      {\n        labels: [\n          \"csiso88598i\",\n          \"iso-8859-8-i\",\n          \"logical\",\n        ],\n        name: \"ISO-8859-8-I\",\n      },\n      {\n        labels: [\n          \"csisolatin6\",\n          \"iso-8859-10\",\n          \"iso-ir-157\",\n          \"iso8859-10\",\n          \"iso885910\",\n          \"l6\",\n          \"latin6\",\n        ],\n        name: \"ISO-8859-10\",\n      },\n      {\n        labels: [\n          \"iso-8859-13\",\n          \"iso8859-13\",\n          \"iso885913\",\n        ],\n        name: \"ISO-8859-13\",\n      },\n      {\n        labels: [\n          \"iso-8859-14\",\n          \"iso8859-14\",\n          \"iso885914\",\n        ],\n        name: \"ISO-8859-14\",\n      },\n      {\n        labels: [\n          \"csisolatin9\",\n          \"iso-8859-15\",\n          \"iso8859-15\",\n          \"iso885915\",\n          \"iso_8859-15\",\n          \"l9\",\n        ],\n        name: \"ISO-8859-15\",\n      },\n      {\n        labels: [\n          \"iso-8859-16\",\n        ],\n        name: \"ISO-8859-16\",\n      },\n      {\n        labels: [\n          \"cskoi8r\",\n          \"koi\",\n          \"koi8\",\n          \"koi8-r\",\n          \"koi8_r\",\n        ],\n        name: \"KOI8-R\",\n      },\n      {\n        labels: [\n          \"koi8-ru\",\n          \"koi8-u\",\n        ],\n        name: \"KOI8-U\",\n      },\n      {\n        labels: [\n          \"csmacintosh\",\n          \"mac\",\n          \"macintosh\",\n          \"x-mac-roman\",\n        ],\n        name: \"macintosh\",\n      },\n      {\n        labels: [\n          \"dos-874\",\n          \"iso-8859-11\",\n          \"iso8859-11\",\n          \"iso885911\",\n          \"tis-620\",\n          \"windows-874\",\n        ],\n        name: \"windows-874\",\n      },\n      {\n        labels: [\n          \"cp1250\",\n          \"windows-1250\",\n          \"x-cp1250\",\n        ],\n        name: \"windows-1250\",\n      },\n      {\n        labels: [\n          \"cp1251\",\n          \"windows-1251\",\n          \"x-cp1251\",\n        ],\n        name: \"windows-1251\",\n      },\n      {\n        labels: [\n          \"ansi_x3.4-1968\",\n          \"ascii\",\n          \"cp1252\",\n          \"cp819\",\n          \"csisolatin1\",\n          \"ibm819\",\n          \"iso-8859-1\",\n          \"iso-ir-100\",\n          \"iso8859-1\",\n          \"iso88591\",\n          \"iso_8859-1\",\n          \"iso_8859-1:1987\",\n          \"l1\",\n          \"latin1\",\n          \"us-ascii\",\n          \"windows-1252\",\n          \"x-cp1252\",\n        ],\n        name: \"windows-1252\",\n      },\n      {\n        labels: [\n          \"cp1253\",\n          \"windows-1253\",\n          \"x-cp1253\",\n        ],\n        name: \"windows-1253\",\n      },\n      {\n        labels: [\n          \"cp1254\",\n          \"csisolatin5\",\n          \"iso-8859-9\",\n          \"iso-ir-148\",\n          \"iso8859-9\",\n          \"iso88599\",\n          \"iso_8859-9\",\n          \"iso_8859-9:1989\",\n          \"l5\",\n          \"latin5\",\n          \"windows-1254\",\n          \"x-cp1254\",\n        ],\n        name: \"windows-1254\",\n      },\n      {\n        labels: [\n          \"cp1255\",\n          \"windows-1255\",\n          \"x-cp1255\",\n        ],\n        name: \"windows-1255\",\n      },\n      {\n        labels: [\n          \"cp1256\",\n          \"windows-1256\",\n          \"x-cp1256\",\n        ],\n        name: \"windows-1256\",\n      },\n      {\n        labels: [\n          \"cp1257\",\n          \"windows-1257\",\n          \"x-cp1257\",\n        ],\n        name: \"windows-1257\",\n      },\n      {\n        labels: [\n          \"cp1258\",\n          \"windows-1258\",\n          \"x-cp1258\",\n        ],\n        name: \"windows-1258\",\n      },\n      {\n        labels: [\n          \"x-mac-cyrillic\",\n          \"x-mac-ukrainian\",\n        ],\n        name: \"x-mac-cyrillic\",\n      },\n    ],\n    heading: \"Legacy single-byte encodings\",\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          \"chinese\",\n          \"csgb2312\",\n          \"csiso58gb231280\",\n          \"gb2312\",\n          \"gb_2312\",\n          \"gb_2312-80\",\n          \"gbk\",\n          \"iso-ir-58\",\n          \"x-gbk\",\n        ],\n        name: \"GBK\",\n      },\n      {\n        labels: [\n          \"gb18030\",\n        ],\n        name: \"gb18030\",\n      },\n    ],\n    heading: \"Legacy multi-byte Chinese (simplified) encodings\",\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          \"big5\",\n          \"big5-hkscs\",\n          \"cn-big5\",\n          \"csbig5\",\n          \"x-x-big5\",\n        ],\n        name: \"Big5\",\n      },\n    ],\n    heading: \"Legacy multi-byte Chinese (traditional) encodings\",\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          \"cseucpkdfmtjapanese\",\n          \"euc-jp\",\n          \"x-euc-jp\",\n        ],\n        name: \"EUC-JP\",\n      },\n      {\n        labels: [\n          \"csiso2022jp\",\n          \"iso-2022-jp\",\n        ],\n        name: \"ISO-2022-JP\",\n      },\n      {\n        labels: [\n          \"csshiftjis\",\n          \"ms932\",\n          \"ms_kanji\",\n          \"shift-jis\",\n          \"shift_jis\",\n          \"sjis\",\n          \"windows-31j\",\n          \"x-sjis\",\n        ],\n        name: \"Shift_JIS\",\n      },\n    ],\n    heading: \"Legacy multi-byte Japanese encodings\",\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          \"cseuckr\",\n          \"csksc56011987\",\n          \"euc-kr\",\n          \"iso-ir-149\",\n          \"korean\",\n          \"ks_c_5601-1987\",\n          \"ks_c_5601-1989\",\n          \"ksc5601\",\n          \"ksc_5601\",\n          \"windows-949\",\n        ],\n        name: \"EUC-KR\",\n      },\n    ],\n    heading: \"Legacy multi-byte Korean encodings\",\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          \"csiso2022kr\",\n          \"hz-gb-2312\",\n          \"iso-2022-cn\",\n          \"iso-2022-cn-ext\",\n          \"iso-2022-kr\",\n        ],\n        name: \"replacement\",\n      },\n      {\n        labels: [\n          \"utf-16be\",\n        ],\n        name: \"UTF-16BE\",\n      },\n      {\n        labels: [\n          \"utf-16\",\n          \"utf-16le\",\n        ],\n        name: \"UTF-16LE\",\n      },\n      {\n        labels: [\n          \"x-user-defined\",\n        ],\n        name: \"x-user-defined\",\n      },\n    ],\n    heading: \"Legacy miscellaneous encodings\",\n  },\n]\n\nexport default encodings"],"names":[],"mappings":"AAAA;;CAEC;;;AACD,MAAM,YAAY;IAChB;QACE,WAAW;YACT;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;SACD;QACD,SAAS;IACX;IACA;QACE,WAAW;YACT;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;iBACD;gBACD,MAAM;YACR;SACD;QACD,SAAS;IACX;IACA;QACE,WAAW;YACT;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;iBACD;gBACD,MAAM;YACR;SACD;QACD,SAAS;IACX;IACA;QACE,WAAW;YACT;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;SACD;QACD,SAAS;IACX;IACA;QACE,WAAW;YACT;gBACE,QAAQ;oBACN;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;SACD;QACD,SAAS;IACX;IACA;QACE,WAAW;YACT;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;SACD;QACD,SAAS;IACX;IACA;QACE,WAAW;YACT;gBACE,QAAQ;oBACN;oBACA;oBACA;oBACA;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;oBACA;iBACD;gBACD,MAAM;YACR;YACA;gBACE,QAAQ;oBACN;iBACD;gBACD,MAAM;YACR;SACD;QACD,SAAS;IACX;CACD;uCAEc"}},
    {"offset": {"line": 2143, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2148, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/table.js"],"sourcesContent":["import Encodings from './encodings'\nimport { UTF8Decoder, UTF8Encoder } from './implementations/utf8'\nimport { UTF16Decoder, UTF16Encoder } from './implementations/utf16'\nimport { GB18030Decoder, GB18030Encoder } from './implementations/gb18030'\nimport { Big5Decoder, Big5Encoder } from './implementations/big5'\nimport { EUCJPDecoder, EUCJPEncoder } from './implementations/euc-jp'\nimport { EUCKRDecoder, EUCKREncoder } from './implementations/euc-kr'\nimport { ISO2022JPDecoder, ISO2022JPEncoder } from './implementations/iso-2022-jp'\nimport { XUserDefinedDecoder, XUserDefinedEncoder } from './implementations/x-user-defined'\nimport { ShiftJISDecoder, ShiftJISEncoder } from './implementations/shift-jis'\nimport { SingleByteDecoder, SingleByteEncoder } from './implementations/single-byte'\nimport index from './indexes';\n\n// 5.2 Names and labels\n\n// TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n// https://github.com/google/closure-compiler/issues/247\n\n\n// Label to encoding registry.\n/** @type {Object.<string,{name:string,labels:Array.<string>}>} */\nexport const label_to_encoding = {}\nEncodings.forEach(({ encodings }) => {\n  encodings.forEach((encoding) => {\n    encoding.labels.forEach((label) => {\n      label_to_encoding[label] = encoding\n    })\n  })\n})\n\n// Registry of of encoder/decoder factories, by encoding name.\nexport const encoders = {\n  'UTF-8'() { // 9.1 utf-8\n    return new UTF8Encoder()\n  },\n  'GBK'(options) { // 11.1.2 gbk encoder;\n    // gbk's encoder is gb18030's encoder with its gbk flag set.\n    return new GB18030Encoder(options, true)\n  },\n  'gb18030'() {\n    return new GB18030Encoder()\n  },\n  'Big5'() {\n    return new Big5Encoder()\n  },\n  'EUC-JP'() {\n    return new EUCJPEncoder()\n  },\n  'EUC-KR'() {\n    return new EUCKREncoder()\n  },\n  'ISO-2022-JP'() {\n    return new ISO2022JPEncoder()\n  },\n  'UTF-16BE'() { // 15.3 utf-16be\n    return new UTF16Encoder(true)\n  },\n  'UTF-16LE'() { // 15.4 utf-16le\n    return new UTF16Encoder()\n  },\n  'x-user-defined'() {\n    return new XUserDefinedEncoder()\n  },\n  'Shift_JIS'() {\n    return new ShiftJISEncoder()\n  },\n}\n\n/** @type {Object.<string, function({fatal:boolean}): Decoder>} */\nexport const decoders = {\n  'UTF-8'(options) { // 9.1.1 utf-8 decoder\n    return new UTF8Decoder(options)\n  },\n  'GBK'(options) { // 11.1.1 gbk decoder;  gbk's decoder is gb18030's decoder.\n    return new GB18030Decoder(options)\n  },\n  'gb18030'(options) {\n    return new GB18030Decoder(options)\n  },\n  'Big5'(options) {\n    return new Big5Decoder(options)\n  },\n  'EUC-JP'(options) {\n    return new EUCJPDecoder(options)\n  },\n  'EUC-KR'(options) {\n    return new EUCKRDecoder(options)\n  },\n  'ISO-2022-JP'(options) {\n    return new ISO2022JPDecoder(options)\n  },\n  'UTF-16BE'(options) { // 15.3.1 utf-16be decoder\n    return new UTF16Decoder(true, options)\n  },\n  'UTF-16LE'(options) { // 15.4.1 utf-16le decoder\n    return new UTF16Decoder(false, options)\n  },\n  'x-user-defined'() {\n    return new XUserDefinedDecoder()\n  },\n  'Shift_JIS'(options) {\n    return new ShiftJISDecoder(options)\n  },\n}\n\nEncodings.forEach(({ heading, encodings }) => {\n  if (heading != 'Legacy single-byte encodings')\n    return\n  encodings.forEach((encoding) => {\n    const name = encoding.name\n    const idx = index(name.toLowerCase())\n    decoders[name] = (options) => {\n      return new SingleByteDecoder(idx, options)\n    }\n    encoders[name] = (options) => {\n      return new SingleByteEncoder(idx, options)\n    }\n  })\n})"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBO,MAAM,oBAAoB,CAAC;AAClC,gKAAU,OAAO,CAAC,CAAC,EAAE,SAAS,EAAE;IAC9B,UAAU,OAAO,CAAC,CAAC;QACjB,SAAS,MAAM,CAAC,OAAO,CAAC,CAAC;YACvB,iBAAiB,CAAC,MAAM,GAAG;QAC7B;IACF;AACF;AAGO,MAAM,WAAW;IACtB;QACE,OAAO;IACT;IACA,OAAM,OAAO;QACX,4DAA4D;QAC5D,OAAO,4LAAmB,SAAS;IACrC;IACA;QACE,OAAO;IACT;IACA;QACE,OAAO;IACT;IACA;QACE,OAAO;IACT;IACA;QACE,OAAO;IACT;IACA;QACE,OAAO;IACT;IACA;QACE,OAAO,wLAAiB;IAC1B;IACA;QACE,OAAO;IACT;IACA;QACE,OAAO;IACT;IACA;QACE,OAAO;IACT;AACF;AAGO,MAAM,WAAW;IACtB,SAAQ,OAAO;QACb,OAAO,sLAAgB;IACzB;IACA,OAAM,OAAO;QACX,OAAO,4LAAmB;IAC5B;IACA,WAAU,OAAO;QACf,OAAO,4LAAmB;IAC5B;IACA,QAAO,OAAO;QACZ,OAAO,sLAAgB;IACzB;IACA,UAAS,OAAO;QACd,OAAO,4LAAiB;IAC1B;IACA,UAAS,OAAO;QACd,OAAO,4LAAiB;IAC1B;IACA,eAAc,OAAO;QACnB,OAAO,wMAAqB;IAC9B;IACA,YAAW,OAAO;QAChB,OAAO,wLAAiB,MAAM;IAChC;IACA,YAAW,OAAO;QAChB,OAAO,wLAAiB,OAAO;IACjC;IACA;QACE,OAAO;IACT;IACA,aAAY,OAAO;QACjB,OAAO,kMAAoB;IAC7B;AACF;AAEA,gKAAU,OAAO,CAAC,CAAC,EAAE,OAAO,EAAE,SAAS,EAAE;IACvC,IAAI,WAAW,gCACb;IACF,UAAU,OAAO,CAAC,CAAC;QACjB,MAAM,OAAO,SAAS,IAAI;QAC1B,MAAM,MAAM,8JAAM,KAAK,WAAW;QAClC,QAAQ,CAAC,KAAK,GAAG,CAAC;YAChB,OAAO,sMAAsB,KAAK;QACpC;QACA,QAAQ,CAAC,KAAK,GAAG,CAAC;YAChB,OAAO,sMAAsB,KAAK;QACpC;IACF;AACF"}},
    {"offset": {"line": 2270, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2275, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/lib/index.js"],"sourcesContent":["import { end_of_stream } from '../utils'\nimport { label_to_encoding } from '../table'\n\nexport default class Stream {\n  /**\n   * A stream represents an ordered sequence of tokens.\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  constructor(tokens) {\n    this.tokens = [...tokens]\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse()\n  }\n  /**\n   * @returns True if end-of-stream has been hit.\n   */\n  endOfStream() {\n    return !this.tokens.length\n  }\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return Get the next token from the stream, or end_of_stream.\n   */\n  read() {\n    if (!this.tokens.length)\n      return end_of_stream\n    return this.tokens.pop()\n  }\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n   * stream.\n   */\n  prepend(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token)\n      while (tokens.length)\n        this.tokens.push(tokens.pop())\n    } else {\n      this.tokens.push(token)\n    }\n  }\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n   * stream.\n   */\n  push(token) {\n    if (Array.isArray(token)) {\n      const tokens = /**@type {!Array.<number>}*/(token)\n      while (tokens.length)\n        this.tokens.unshift(tokens.shift())\n    } else {\n      this.tokens.unshift(token)\n    }\n  }\n}\n\nexport const DEFAULT_ENCODING = 'utf-8'\n\n\n/**\n * Returns the encoding for the label.\n * @param {string} label The encoding label.\n */\nexport function getEncoding(label) {\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  label = String(label).trim().toLowerCase()\n\n  // 2. If label is an ASCII case-insensitive match for any of the\n  // labels listed in the table below, return the corresponding\n  // encoding, and failure otherwise.\n  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n    return label_to_encoding[label]\n  }\n  return null\n}\n\n\n//\n// 5. Encodings\n//\n\n// 5.1 Encoders and decoders\n\n// /** @interface */\n// function Decoder() {}\n// Decoder.prototype = {\n//   /**\n//    * @param {Stream} stream The stream of bytes being decoded.\n//    * @param {number} bite The next byte read from the stream.\n//    * @return {?(number|!Array.<number>)} The next code point(s)\n//    *     decoded, or null if not enough data exists in the input\n//    *     stream to decode a complete code point, or |finished|.\n//    */\n//   handler: function(stream, bite) {},\n// }\n\n// /** @interface */\n// function Encoder() {}\n// Encoder.prototype = {\n//   /**\n//    * @param {Stream} stream The stream of code points being encoded.\n//    * @param {number} code_point Next code point read from the stream.\n//    * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n//    */\n//   handler: function(stream, code_point) {},\n// }"],"names":[],"mappings":";;;;;;;;;;AAGe,MAAM;IACnB;;;;GAIC,GACD,YAAY,MAAM,CAAE;QAClB,IAAI,CAAC,MAAM,GAAG;eAAI;SAAO;QACzB,6DAA6D;QAC7D,IAAI,CAAC,MAAM,CAAC,OAAO;IACrB;IACA;;GAEC,GACD,cAAc;QACZ,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM;IAC5B;IACA;;;;;;GAMC,GACD,OAAO;QACL,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,EACrB;QACF,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG;IACxB;IACA;;;;;;;GAOC,GACD,QAAQ,KAAK,EAAE;QACb,IAAI,MAAM,OAAO,CAAC,QAAQ;YACxB,IAAI,SAAsC;YAC1C,MAAO,OAAO,MAAM,CAClB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,GAAG;QAC/B,OAAO;YACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QACnB;IACF;IACA;;;;;;;GAOC,GACD,KAAK,KAAK,EAAE;QACV,IAAI,MAAM,OAAO,CAAC,QAAQ;YACxB,MAAM,SAAsC;YAC5C,MAAO,OAAO,MAAM,CAClB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,KAAK;QACpC,OAAO;YACL,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC;QACtB;IACF;AACF;AAEO,MAAM,mBAAmB;AAOzB,SAAS,YAAY,KAAK;IAC/B,kEAAkE;IAClE,QAAQ,OAAO,OAAO,IAAI,GAAG,WAAW;IAExC,gEAAgE;IAChE,6DAA6D;IAC7D,mCAAmC;IACnC,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,wKAAoB,QAAQ;QAClE,OAAO,qKAAiB,CAAC,MAAM;IACjC;IACA,OAAO;AACT,EAGA,EAAE;CACF,eAAe;CACf,EAAE;CAEF,4BAA4B;CAE5B,oBAAoB;CACpB,wBAAwB;CACxB,wBAAwB;CACxB,QAAQ;CACR,iEAAiE;CACjE,gEAAgE;CAChE,kEAAkE;CAClE,mEAAmE;CACnE,kEAAkE;CAClE,QAAQ;CACR,wCAAwC;CACxC,IAAI;CAEJ,oBAAoB;CACpB,wBAAwB;CACxB,wBAAwB;CACxB,QAAQ;CACR,uEAAuE;CACvE,wEAAwE;CACxE,0EAA0E;CAC1E,QAAQ;CACR,8CAA8C;CAC9C,IAAI"}},
    {"offset": {"line": 2380, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2385, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/lib/TextEncoder.js"],"sourcesContent":["import Stream, { DEFAULT_ENCODING, getEncoding } from './'\nimport { end_of_stream, finished, stringToCodePoints } from '../utils'\nimport { encoders } from '../table'\n\n// 8.2 Interface TextEncoder\n\nexport default class TextEncoder {\n  /**\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} [options] NONSTANDARD.\n   */\n  constructor(label, options = {}) {\n    // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n    this._encoding = null\n    /** @private @type {?Encoder} */\n    this._encoder = null\n\n    // Non-standard\n    /** @private @type {boolean} */\n    this._do_not_flush = false\n    /** @private @type {string} */\n    this._fatal = options['fatal'] ? 'fatal' : 'replacement'\n\n    // 2. Set enc's encoding to UTF-8's encoder.\n    if (options['NONSTANDARD_allowLegacyEncoding']) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING\n      var encoding = getEncoding(label)\n      if (encoding === null || encoding.name === 'replacement')\n        throw RangeError('Unknown encoding: ' + label)\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' +\n                    ' Did you forget to include encoding-indexes.js first?')\n      }\n      this._encoding = encoding\n    } else {\n      // Standard behavior.\n      this._encoding = getEncoding('utf-8')\n\n      if (label !== undefined && 'console' in global) {\n        console.warn('TextEncoder constructor called with encoding label, '\n                      + 'which is ignored.')\n      }\n    }\n  }\n  get encoding() {\n    return this._encoding.name.toLowerCase()\n  }\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   */\n  encode(opt_string = '', options = {}) {\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n    if (!this._do_not_flush)\n      this._encoder = encoders[this._encoding.name]({\n        fatal: this._fatal === 'fatal' })\n    this._do_not_flush = Boolean(options['stream'])\n\n    // 1. Convert input to a stream.\n    const input = new Stream(stringToCodePoints(opt_string))\n\n    // 2. Let output be a new stream\n    const output = []\n\n    /** @type {?(number|!Array.<number>)} */\n    var result\n    // 3. While true, run these substeps:\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read()\n      if (token === end_of_stream)\n        break\n      // 2. Let result be the result of processing token for encoder,\n      // input, output.\n      result = this._encoder.handler(input, token)\n      if (result === finished)\n        break\n      if (Array.isArray(result))\n        output.push.apply(output, /**@type {!Array.<number>}*/(result))\n      else\n        output.push(result)\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read())\n        if (result === finished)\n          break\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result))\n        else\n          output.push(result)\n      }\n      this._encoder = null\n    }\n    // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n    return new Uint8Array(output)\n  }\n}"],"names":[],"mappings":";;;;;;;;;;AAMe,MAAM;IACnB;;;GAGC,GACD,YAAY,KAAK,EAAE,UAAU,CAAC,CAAC,CAAE;QAC/B,+DAA+D;QAE/D,aAAa,GACb,IAAI,CAAC,SAAS,GAAG;QACjB,8BAA8B,GAC9B,IAAI,CAAC,QAAQ,GAAG;QAEhB,eAAe;QACf,6BAA6B,GAC7B,IAAI,CAAC,aAAa,GAAG;QACrB,4BAA4B,GAC5B,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,QAAQ,GAAG,UAAU;QAE3C,4CAA4C;QAC5C,IAAI,OAAO,CAAC,kCAAkC,EAAE;YAC9C,wBAAwB;YACxB,QAAQ,UAAU,YAAY,OAAO;YACrC,IAAI,WAAW,uKAAY;YAC3B,IAAI,aAAa,QAAQ,SAAS,IAAI,KAAK,eACzC,MAAM,WAAW,uBAAuB;YAC1C,IAAI,CAAC,4JAAQ,CAAC,SAAS,IAAI,CAAC,EAAE;gBAC5B,MAAM,MAAM,yBACA;YACd;YACA,IAAI,CAAC,SAAS,GAAG;QACnB,OAAO;YACL,qBAAqB;YACrB,IAAI,CAAC,SAAS,GAAG,uKAAY;YAE7B,IAAI,UAAU,aAAa,aAAa,QAAQ;gBAC9C,QAAQ,IAAI,CAAC,yDACG;YAClB;QACF;IACF;IACA,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW;IACxC;IACA;;;GAGC,GACD,OAAO,aAAa,EAAE,EAAE,UAAU,CAAC,CAAC,EAAE;QACpC,0DAA0D;QAC1D,gEAAgE;QAChE,0DAA0D;QAC1D,IAAI,CAAC,IAAI,CAAC,aAAa,EACrB,IAAI,CAAC,QAAQ,GAAG,4JAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YAC5C,OAAO,IAAI,CAAC,MAAM,KAAK;QAAQ;QACnC,IAAI,CAAC,aAAa,GAAG,QAAQ,OAAO,CAAC,SAAS;QAE9C,gCAAgC;QAChC,MAAM,QAAQ,uKAAW,uKAAmB;QAE5C,gCAAgC;QAChC,MAAM,SAAS,EAAE;QAEjB,sCAAsC,GACtC,IAAI;QACJ,qCAAqC;QACrC,MAAO,KAAM;YACX,oDAAoD;YACpD,IAAI,QAAQ,MAAM,IAAI;YACtB,IAAI,6KACF;YACF,+DAA+D;YAC/D,iBAAiB;YACjB,SAAS,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO;YACtC,IAAI,yKACF;YACF,IAAI,MAAM,OAAO,CAAC,SAChB,OAAO,IAAI,CAAC,KAAK,CAAC,QAAqC;iBAEvD,OAAO,IAAI,CAAC;QAChB;QACA,mCAAmC;QACnC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,MAAO,KAAM;gBACX,SAAS,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,MAAM,IAAI;gBAChD,IAAI,yKACF;gBACF,IAAI,MAAM,OAAO,CAAC,SAChB,OAAO,IAAI,CAAC,KAAK,CAAC,QAAqC;qBAEvD,OAAO,IAAI,CAAC;YAChB;YACA,IAAI,CAAC,QAAQ,GAAG;QAClB;QACA,iEAAiE;QACjE,8DAA8D;QAC9D,qBAAqB;QACrB,OAAO,IAAI,WAAW;IACxB;AACF"}},
    {"offset": {"line": 2471, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2476, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/text-decoding/src/lib/TextDecoder.js"],"sourcesContent":["import Stream, { DEFAULT_ENCODING, getEncoding } from './'\nimport { end_of_stream, finished, codePointsToString } from '../utils'\nimport { decoders } from '../table'\n\n// 8.1 Interface TextDecoder\n\nexport default class TextDecoder {\n  /**\n   * @param {string=} label The label of the encoding; defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n  constructor(label = DEFAULT_ENCODING, options = {}) {\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null\n    /** @private @type {?Decoder} */\n    this._decoder = null\n    /** @private @type {boolean} */\n    this._ignoreBOM = false\n    /** @private @type {boolean} */\n    this._BOMseen = false\n    /** @private @type {string} */\n    this._error_mode = 'replacement'\n    /** @private @type {boolean} */\n    this._do_not_flush = false\n\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    const encoding = getEncoding(label)\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name == 'replacement')\n      throw RangeError('Unknown encoding: ' + label)\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' +\n                  ' Did you forget to include encoding-indexes.js first?')\n    }\n\n    // 4. Set dec's encoding to encoding.\n    this._encoding = encoding\n\n    // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n    if (options['fatal'])\n      this._error_mode = 'fatal'\n\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n    if (options['ignoreBOM'])\n      this._ignoreBOM = true\n  }\n\n  get encoding() {\n    return this._encoding.name.toLowerCase()\n  }\n  get fatal() {\n    return this._error_mode === 'fatal'\n  }\n  get ignoreBOM() {\n    return this._ignoreBOM\n  }\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return The decoded string.\n   */\n  decode(input, options = {}) {\n    let bytes\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input)\n    } else if (typeof input === 'object' && 'buffer' in input &&\n                input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n        input.byteOffset,\n        input.byteLength)\n    } else {\n      bytes = new Uint8Array(0)\n    }\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal' })\n      this._BOMseen = false\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options['stream'])\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    const input_stream = new Stream(bytes)\n\n    // 4. Let output be a new stream.\n    const output = []\n\n    /** @type {?(number|!Array.<number>)} */\n    let result\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      const token = input_stream.read()\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream)\n        break\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token)\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished)\n        break\n\n      if (result !== null) {\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result))\n        else\n          output.push(result)\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read())\n        if (result === finished)\n          break\n        if (result === null)\n          continue\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result))\n        else\n          output.push(result)\n      } while (!input_stream.endOfStream())\n      this._decoder = null\n    }\n\n    return this.serializeStream(output)\n  }\n  // A TextDecoder object also has an associated serialize stream\n  // algorithm...\n  /**\n   * @param {!Array.<number>} stream\n   */\n  serializeStream(stream) {\n    // 1. Let token be the result of reading from stream.\n    // (Done in-place on array, rather than as a stream)\n\n    // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n    // BOM flag and BOM seen flag are unset, run these subsubsteps:\n    if (['UTF-8', 'UTF-16LE', 'UTF-16BE'].includes(this._encoding.name) &&\n        !this._ignoreBOM && !this._BOMseen) {\n      if (stream.length > 0 && stream[0] === 0xFEFF) {\n        // 1. If token is U+FEFF, set BOM seen flag.\n        this._BOMseen = true\n        stream.shift()\n      } else if (stream.length > 0) {\n        // 2. Otherwise, if token is not end-of-stream, set BOM seen\n        // flag and append token to stream.\n        this._BOMseen = true\n      } else {\n        // 3. Otherwise, if token is not end-of-stream, append token\n        // to output.\n        // (no-op)\n      }\n    }\n    // 4. Otherwise, return output.\n    return codePointsToString(stream)\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2625, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}